{
  "metadata": {
    "file_name": "MIPS_Assembly_Language_small_163.pdf",
    "file_type": "pdf",
    "file_size": "1.52 MB",
    "page_count": 163
  },
  "pages": [
    {
      "page_number": 1,
      "text": "MIPS\nAssembly Language\nProgramming \nusing QtSpim\nEd Jorgensen, Ph.D.\nVersion 1.1.50\nJuly 2019",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page1_img1.jpeg"
      ],
      "img_summary_files": [],
      "img_vision_files": [
        "output\\images\\img_vision\\MIPS_Assembly_Language_small_163_page1_img1_vision.json"
      ],
      "time_taken": "7.26 sec"
    },
    {
      "page_number": 2,
      "text": "Cover image:\nMIPS R3000 Custom Chip\nhttp://commons.wikimedia.org/wiki/File:RCP-NUS_01.jpg\nSpim is copyrighted by James Larus and distributed under a BSD license.\nCopyright (c) 1990-2011, James R. Larus.  All rights reserved.\nCopyright © 2013, 2014, 2015, 2016, 2017 by Ed Jorgensen\nYou are free: \nTo Share — to copy, distribute and transmit the work \nTo Remix — to adapt the work \nUnder the following conditions: \nAttribution — you must attribute the work in the manner specified by the author \nor licensor (but not in any way that suggests that they endorse you or your use of\nthe work). \nNoncommercial — you may not use this work for commercial purposes. \nShare Alike — if you alter, transform, or build upon this work, you may \ndistribute the resulting work only under the same or similar license to this one.",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page2_img1.jpeg"
      ],
      "img_summary_files": [],
      "img_vision_files": [
        "output\\images\\img_vision\\MIPS_Assembly_Language_small_163_page2_img1_vision.json"
      ],
      "time_taken": "9.85 sec"
    },
    {
      "page_number": 3,
      "text": "Table of Contents\n 1.0     Introduction...........................................................................................................1\n 1.1    Additional References.........................................................................................1\n 2.0     MIPS Architecture Overview..............................................................................3\n 2.1    Architecture Overview........................................................................................3\n 2.2    Data Types/Sizes.................................................................................................4\n 2.3    Memory...............................................................................................................4\n 2.4    Memory Layout...................................................................................................6\n 2.5    CPU Registers.....................................................................................................6\n 2.5.1    Reserved Registers......................................................................................7\n 2.5.2    Miscellaneous Registers..............................................................................8\n 2.6    CPU / FPU Core Configuration..........................................................................9\n 3.0     Data Representation...........................................................................................11\n 3.1    Integer Representation.......................................................................................11\n 3.1.1    Two's Complement....................................................................................13\n 3.1.2    Byte Example............................................................................................13\n 3.1.3    Halfword Example.....................................................................................13\n 3.2    Unsigned and Signed Addition.........................................................................14\n 3.3    Floating-point Representation...........................................................................14\n 3.3.1    IEEE 32-bit Representation.......................................................................14\n 3.3.1.1    IEEE 32-bit Representation Examples..............................................15\n 3.3.1.1.1    Example → -7.7510.....................................................................16\n 3.3.1.1.2    Example → -0.12510...................................................................16\n 3.3.1.1.3    Example → 4144000016.............................................................17\n 3.3.2    IEEE 64-bit Representation.......................................................................17\n 4.0     QtSpim Program Formats.................................................................................19\n 4.1    Assembly Process..............................................................................................19\n 4.2    Comments..........................................................................................................19\n 4.3    Assembler Directives........................................................................................19\n 4.4    Data Declarations..............................................................................................20\n 4.4.1    Integer Data Declarations..........................................................................20\n 4.4.2    String Data Declarations............................................................................21\n 4.4.3    Floating-Point Data Declarations..............................................................22\n 4.5    Constants...........................................................................................................22\n 4.6    Program Code....................................................................................................23\n 4.7    Labels................................................................................................................23\n 4.8    Program Template.............................................................................................24",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "9.86 sec"
    },
    {
      "page_number": 4,
      "text": "Table of Contents\n 5.0     Instruction Set Overview....................................................................................25\n 5.1    Pseudo-Instructions vs Bare-Instructions..........................................................25\n 5.2    Notational Conventions.....................................................................................25\n 5.3    Data Movement.................................................................................................26\n 5.3.1    Load and Store...........................................................................................26\n 5.3.2    Move..........................................................................................................28\n 5.4    Integer Arithmetic Operations...........................................................................29\n 5.4.1    Example Program, Integer Arithmetic......................................................32\n 5.5    Logical Operations............................................................................................33\n 5.5.1    Shift Operations.........................................................................................35\n 5.5.1.1    Logical Shift......................................................................................36\n 5.5.1.2    Arithmetic Shift.................................................................................37\n 5.5.1.3    Shift Operations, Examples...............................................................37\n 5.6    Control Instructions...........................................................................................39\n 5.6.1    Unconditional Control Instructions...........................................................39\n 5.6.2    Conditional Control Instructions...............................................................39\n 5.6.3    Example Program, Sum of Squares...........................................................41\n 5.7    Floating-Point Instructions................................................................................42\n 5.7.1    Floating-Point Register Usage...................................................................42\n 5.7.2    Floating-Point Data Movement.................................................................43\n 5.7.3    Integer / Floating-Point Register Data Movement....................................44\n 5.7.4    Integer / Floating-Point Conversion Instructions......................................45\n 5.7.5    Floating-Point Arithmetic Operations.......................................................47\n 5.7.6    Example Programs.....................................................................................48\n 5.7.6.1    Example Program, Floating-Point Arithmetic...................................49\n 5.7.6.2    Example Program, Integer / Floating-Point Conversion...................50\n 6.0     Addressing Modes...............................................................................................53\n 6.1    Direct Mode.......................................................................................................53\n 6.2    Immediate Mode...............................................................................................53\n 6.3    Indirection.........................................................................................................54\n 6.3.1    Bounds Checking.......................................................................................54\n 6.4    Examples...........................................................................................................55\n 6.4.1    Example Program, Sum and Average.......................................................55\n 6.4.2    Example Program, Median........................................................................57\n 7.0     Stack.....................................................................................................................59\n 7.1    Stack Example...................................................................................................59\n 7.2    Stack Implementation........................................................................................60\nPage ii",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "9.86 sec"
    },
    {
      "page_number": 5,
      "text": "Table of Contents\n 7.3    Push...................................................................................................................60\n 7.4    Pop.....................................................................................................................61\n 7.5    Multiple push's/pop's.........................................................................................61\n 7.6    Example Program, Stack Usage........................................................................61\n 8.0     Procedures/Functions.........................................................................................65\n 8.1    MIPS Calling Conventions................................................................................65\n 8.2    Procedure/Function Format...............................................................................66\n 8.3    Caller Conventions............................................................................................66\n 8.4    Linkage..............................................................................................................67\n 8.5    Argument Transmission....................................................................................68\n 8.5.1    Call-by-Value............................................................................................68\n 8.5.2    Call-by-Reference......................................................................................68\n 8.5.3    Argument Transmission Conventions.......................................................68\n 8.6    Function Results................................................................................................69\n 8.7    Registers Preservation Conventions..................................................................69\n 8.8    Miscellaneous Register Usage..........................................................................70\n 8.9    Summary, Callee Conventions..........................................................................70\n 8.10    Call Frame.......................................................................................................71\n 8.10.1.1    Stack Dynamic Local Variables......................................................71\n 8.11    Procedure Examples........................................................................................72\n 8.11.1    Example Program, Power Function.........................................................72\n 8.11.2    Example program, Summation Function.................................................73\n 8.11.3    Example Program, Pythagorean Theorem Procedure.............................76\n 9.0     QtSpim System Service Calls.............................................................................82\n 9.1    Supported QtSpim System Services..................................................................82\n 9.2    QtSpim System Services Examples..................................................................85\n 9.2.1    Example Program, Display String and Integer..........................................85\n 9.2.2    Example Program, Display Array.............................................................86\n 9.2.3    Example Program, Read Integer................................................................88\n 9.2.4    Example Program, Read String.................................................................90\n 10.0     Multi-dimension Array Implementation........................................................93\n 10.1    High-Level Language View............................................................................93\n 10.2    Row-Major......................................................................................................94\n 10.3    Column-Major.................................................................................................95\n 10.4    Example Program, Matrix Diagonal Summation............................................96\n 11.0     Recursion...........................................................................................................99\nPage iii",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "9.86 sec"
    },
    {
      "page_number": 6,
      "text": "Table of Contents\n 11.1    Recursion Example, Factorial.........................................................................99\n 11.1.1    Example Program, Recursive Factorial Function..................................100\n 11.1.2    Recursive Factorial Function Call Tree.................................................103\n 11.2    Recursion Example, Fibonacci......................................................................104\n 11.2.1    Example Program, Recursive Fibonacci Function................................105\n 11.2.2    Recursive Fibonacci Function Call Tree...............................................108\n 12.0     Appendix A – Example Program...................................................................111\n 13.0     Appendix B – QtSpim Tutorial......................................................................115\n 13.1    Downloading and Installing QtSpim.............................................................115\n 13.1.1    QtSpim Download URLs......................................................................115\n 13.1.2    Installing QtSpim...................................................................................115\n 13.2    Working Directory........................................................................................116\n 13.3    Sample Program............................................................................................116\n 13.4    QtSpim – Loading and Executing Programs.................................................116\n 13.4.1    Starting QtSpim.....................................................................................116\n 13.4.2    Main Screen...........................................................................................117\n 13.4.3    Load Program........................................................................................117\n 13.4.4    Data Window.........................................................................................120\n 13.4.5    Program Execution................................................................................121\n 13.4.6    Log File.................................................................................................122\n 13.4.7    Making Updates.....................................................................................125\n 13.5    Debugging.....................................................................................................125\n 14.0     Appendix C – MIPS Instruction Set..............................................................133\n 14.1    Arithmetic Instructions..................................................................................134\n 14.2    Comparison Instructions...............................................................................136\n 14.3    Branch and Jump Instructions.......................................................................137\n 14.4    Load Instructions...........................................................................................141\n 14.5    Logical Instructions.......................................................................................143\n 14.6    Store Instructions...........................................................................................145\n 14.7    Data Movement Instructions.........................................................................146\n 14.8    Floating-Point Instructions............................................................................148\n 14.9    Exception and Trap Handling Instructions....................................................152\n 15.0     Appendix D – ASCII Table............................................................................153\n 16.0     Alphabetical Index..........................................................................................155\nPage iv",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "9.87 sec"
    },
    {
      "page_number": 7,
      "text": "1.0\nIntroduction\nThere are a number of excellent, comprehensive, and in-depth texts on MIPS assembly \nlanguage programming.  This is not one of them.\nThe purpose of this text is to provide a simple and free reference for university level \nprogramming and architecture units that include a brief section covering MIPS assembly\nlanguage programming.  The text assumes usage of the QtSpim simulator.  An appendix\nis included that covers the download, installation, and basic use of the QtSpim \nsimulator.\nThe scope of this text addresses basic MIPS assembly language programming including \ninstruction set usage, stacks, procedure/function calls, QtSpim simulator system \nservices, multiple dimension arrays, and basic recursion.\n 1.1 Additional References\nSome key references for additional information are listed below:\n•\nMIPS Assembly-language Programmer Guide, Silicon Graphics\n•\nMIPS Software Users Manual, MIPS Technologies, Inc.\n•\nComputer Organization and Design: The Hardware/Software Interface, \nHennessy and Patterson\nMore information regarding these references can be found on the Internet.\nPage 1",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "9.87 sec"
    },
    {
      "page_number": 8,
      "text": "Chapter 1.0 ◄ Introduction\nPage 2",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "9.87 sec"
    },
    {
      "page_number": 9,
      "text": "2.0\nMIPS Architecture Overview\nThis chapter presents a basic, general overview of the architecture of the MIPS \nprocessor.\nThe MIPS architecture is a Reduced Instruction Set Computer (RISC).  This means that \nthere is a smaller number of instructions that use a uniform instruction encoding format. \nEach instruction/operation does one thing (memory access, computation, conditional, \netc.).  The idea is to make the lesser number of instructions execute faster.  In general \nRISC architectures, and specifically the MIPS architecture, are designed for high-speed \nimplementations.\n 2.1 Architecture Overview\nThe basic components of a computer include a Central Processing Unit (CPU), Primary \nStorage or Random Access Memory (RAM), Secondary Storage (i.e., Disk Drive, SSD, \netc.), Input/Output devices (i.e., screen and keyboard), and an interconnection referred \nto as BUS.  A very basic diagram of a computer architecture is as follows:\nPrograms and data are typically stored on secondary storage (i.e. SSD, disk drive).  \nPage 3\nIllustration 1: Computer Architecture\nScreen / Keyboard / \nMouse\nSecondary Storage - \nDisk Drive / SSD / \nOther Storage Media\nPrimary Storage - \nRandom Access \nMemory (RAM)\nCPU\nBUS \n(Interconnection)",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page9_img1.png"
      ],
      "img_summary_files": [],
      "img_vision_files": [
        "output\\images\\img_vision\\MIPS_Assembly_Language_small_163_page9_img1_vision.json"
      ],
      "time_taken": "11.63 sec"
    },
    {
      "page_number": 10,
      "text": "Chapter 2.0 ◄ MIPS Architecture Overview\nWhen a program is executed, it must be copied from the disk drive into the RAM \nmemory.  The CPU executes the program from RAM.  This is similar to storing a term \npaper on the disk drive, and when writing/editing the term paper, it is copied from the \ndisk drive into memory.  When done, the updated version is stored back to the disk \ndrive.\n 2.2 Data Types/Sizes\nThe basic data types include integer, floating-point, and characters.\nThis architecture supports data storage sizes of byte, halfword (sometimes referred to as \njust half), or word sizes.  Floating-point must be of either word (32-bit) size or double \nword (64-bit) size.  Character data is typically a byte and a string is a series of sequential\nbytes.\nThe MIPS architecture supports the following data/memory sizes:\nName\nSize\nbyte\n8-bit integer\nhalfword\n16-bit integer\nword\n32-bit integer\nfloat\n32-bit floating-point number\ndouble\n64-bit floating-point number\nThe halfword is often referred to as just 'half '.  Lists or arrays (sets of memory) can be \nreserved in any of these types.  In addition, an arbitrary number of bytes can be defined \nwith the \".space\" directive.\n 2.3 Memory\nMemory can be viewed as a series of bytes, one after another.  That is, memory is byte \naddressable.  This means each memory address holds one byte of information.  To store \na word, four bytes are required which use four memory addresses.\nAdditionally, the MIPS architecture as simulated in QtSpim is little-endian.  This means\nthat the Least Significant Byte (LSB) is stored in the lowest memory address.  The Most\nSignificant Byte (MSB) is stored in the highest memory location.\nPage 4",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.63 sec"
    },
    {
      "page_number": 11,
      "text": "Chapter  2.0 ► MIPS Architecture Overview\nFor a word (32-bits), the MSB and LSB are allocated as shown below.\n31\n30\n29\n28\n27\n26\n25\n24\n23\n22\n21\n20\n19\n18\n17\n16\n15\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\nMSB\nLSB\nFor example, assuming the following declarations:\nnum1:   .word\n42\nnum2:   .word\n5000000\nRecall that 4210 in hex, word size, is 0x0000002A and 5,000,00010 in hex, word size, is \n0x004C4B40.\nFor a little-endian architecture, the memory picture would be as follows:\nvariable\nname\nvalue\naddress\n?\n0x100100C\n00\n0x100100B\n4C\n0x100100A\n4B\n0x1001009\nNum2 →\n40\n0x1001008\n00\n0x1001007\n00\n0x1001006\n00\n0x1001005\nNum1 →\n2A\n0x1001004\n?\n0x1001003\nBased on the little-endian architecture, the LSB is stored in the lowest memory address \nand the MSB is stored in the highest memory location.\nPage 5",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.64 sec"
    },
    {
      "page_number": 12,
      "text": "Chapter 2.0 ◄ MIPS Architecture Overview\n 2.4 Memory Layout\nThe general memory layout for a program is as shown:\nhigh memory\nstack\nheap\nuninitialized data\ndata \ntext (code)\nlow memory\nreserved\nThe reserved section is not available to user programs.  The text (or code) section is \nwhere the machine language (i.e., the 1's and 0's that represent the code) is stored.  The \ndata section is where the initialized data is stored.  This includes declared variables that \nhave been provided an initial value at assemble time.  The uninitialized data section is \nwhere declared variables that have not been provided an initial value are stored.  If \naccessed before being set, the value will not be meaningful.  The heap is where \ndynamically allocated data will be stored (if requested).  The stack starts in high \nmemory and grows downward.\nThe QtSpim simulator does not distinguish between the initialized and uninitialized data\nsections.  Later sections will provide additional detail for the text and data sections. \n 2.5 CPU Registers\nA CPU register, or just register, is a temporary storage or working location built into the\nCPU itself (separate from memory).  Computations are typically performed by the CPU \nusing registers.\nThe MIPS has 32, 32-bit integer registers ($0 through $31) and 32, 32-bit floating-point \nregisters ($f0 through $f31).  Some of the integer registers are used for special purposes.\nFor example, $29 is dedicated for use as the stack pointer register, referred to as $sp.\nPage 6",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.64 sec"
    },
    {
      "page_number": 13,
      "text": "Chapter  2.0 ► MIPS Architecture Overview\nThe registers available and typical register usage is described in the following table.\nRegister\nName\nRegister\nNumber\nRegister Usage\n$zero\n$0\nHardware set to 0\n$at\n$1\nAssembler temporary\n$v0 - $v1\n$2 - $3\nFunction result (low/high)\n$a0 - $a3\n$4 - $7\nArgument Register 1\n$t0 - $t7\n$8 - $15\nTemporary registers\n$s0 - $s7\n$16 - $23\nSaved registers\n$t8 - $t9\n$24 - $25\nTemporary registers\n$k0 - $k1\n$26 - $27\nReserved for OS kernel\n$gp\n$28\nGlobal pointer\n$sp\n$29\nStack pointer\n$fp\n$30\nFrame pointer\n$ra\n$31\nReturn address\nThe register names convey specific usage information.  The register names will be used \nin the remainder of this document.  Further sections will expand on register usage \nconventions and address the 'temporary' and 'saved' registers.\n 2.5.1 Reserved Registers\nThe following reserved registers should not be used in user programs.\nRegister Name\nRegister Usage\n$k0 - $k1\nReserved for use by the\nOperating System\n$at\nAssembler temporary\n$gp\nGlobal pointer\n$epc\nException program counter\nPage 7",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.64 sec"
    },
    {
      "page_number": 14,
      "text": "Chapter 2.0 ◄ MIPS Architecture Overview\nThe $k0 and $k1 registers are reserved for use by the operating system and should not \nbe used in user programs.  The $at register is used by the assembler and should not be \nused in user programs.  The $gp register is used as a pointer to global data (as needed) \nand should not be used in user programs.\n 2.5.2 Miscellaneous Registers\nIn addition to the previously listed registers, there are some miscellaneous registers \nwhich are listed in the table:\nRegister Name\nRegister Usage\n$pc\nProgram counter\n$status or $psw\nStatus Register\n$cause\nException cause register\n$hi\nUsed for some\nmultiple/divide operations\n$lo\nThe $pc or program counter register points to the next instruction to be executed and is \nautomatically updated by the CPU after each instruction is executed.  This register is not\ntypically accessed directly by user programs.\nThe $status or status register, also called $psw, is the processor status register and is \nupdated after each instruction by the CPU.  This register is not typically directly \naccessed by user programs.\nThe $cause or exception cause register is used by the CPU in the event of an exception \nor unexpected interruption in program control flow.  Examples of exceptions include \ndivision by 0, attempting to access an illegal memory address, or attempting to execute \nan invalid instruction (e.g., trying to execute a data item instead of code).\nThe $hi and $lo registers are used by some specialized multiply and divide instructions. \nFor example, a multiple of two 32-bit values can generate a 64-bit result, which is stored\nin $hi and $lo (32-bits each or a total of 64-bits).\nPage 8",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.64 sec"
    },
    {
      "page_number": 15,
      "text": "Chapter  2.0 ► MIPS Architecture Overview\n 2.6 CPU / FPU Core Configuration\nThe following diagram shows a basic configuration of the MIPS processor internal \narchitecture.\nThe FPU (floating-point unit) is also referred to as the FPU co-processor or simply co-\nprocessor 1.\nPage 9\nCPU\ninteger\noperations\n$0 - $31\nMIPS Chip Core Configuration\nFPU\nfloat\noperations\n$f0 - $f31",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.64 sec"
    },
    {
      "page_number": 16,
      "text": "Chapter 2.0 ◄ MIPS Architecture Overview\nPage 10",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.64 sec"
    },
    {
      "page_number": 17,
      "text": "3.0\nData Representation\nData representation refers to how information is stored within the computer.  There is a \nspecific method for storing integers which is different than storing floating-point values \nwhich is different than storing characters.  This chapter presents a brief summary of the \ninteger, floating-point, and ASCII representation schemes.  It is assumed the reader is \nalready generally familiar with the binary, decimal, and hexadecimal numbering \nsystems.\n 3.1 Integer Representation\nRepresenting integer numbers refers to how the computer stores or represents a number \nin memory.  As you know, the computer represents numbers in binary.  However, the \ncomputer has a limited amount of space that can be used for each number or variable.  \nThis directly impacts the size, or range, of the number that can be represented.  For \nexample, a byte (8 bits) can be used to represent 28 or 256 different numbers.  Those 256\ndifferent numbers can be unsigned (all positive) in which case we can represent any \nnumber between 0 and 255 (inclusive).  If we choose signed (positive and negative), \nthen we can represent any number between -128 and +127 (inclusive).\nIf that range is not large enough to handle the intended values, a larger size must be \nused.  For example, a halfword (16 bits) can be used to represent 216 or 65,536 different \nnumbers, and a word can be used to represent 232 or 4,294,967,296 different numbers.  \nSo, if you wanted to store a value of 100,000 then a word would be required.\nThe following table shows the ranges associated with typical sizes:\nSize\nSize\nUnsigned Range\nSigned Range\nBytes (8 bits)\n28\n0 to 255\n-128 to +127\nHalfwords (16 bits)\n216\n0 to 65,535\n−32,768 to +32,767\nWords (32 bits)\n232\n0 to 4,294,967,295\n−2,147,483,648 to\n+2,147,483,647\nPage 11",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 18,
      "text": "Chapter 3.0 ◄ Data Representation\nIn order to determine if a value can be represented, you will need to know the size of \nstorage element (byte, halfword, word) being used and if the values are signed or \nunsigned values.\n•\nFor representing unsigned values within the range of a given storage size, \nstandard binary is used.\n•\nFor representing signed values within the range, two's complement is used. \nSpecifically, the two's complement encoding process applies to the values in the \nnegative range.  For values within the positive range, standard binary is used.\nAdditional detail regarding two's complement is provided in the next section.\nFor example, the unsigned byte range can be represented using a number line as follows:\nFor example, the signed byte range can also be represented using a number line as \nfollows:\nThe same concept applies to halfwords and words with larger ranges.\nUnsigned values have a different, positive only, range.  The range of the signed value \nhas some overlap with the unsigned values.  For example, when the unsigned and signed\nvalues are within the overlapping positive range (0 to +127):\n•\nA signed byte representation of 12 is 0x0C16 \n•\nAn unsigned byte representation of -12 is also 0x0C16 \nWhen the unsigned and signed values are outside the overlapping range: \n•\nA signed byte representation of -15 is 0xF116 \n•\nAn unsigned byte representation of 241 is also 0xF116 \nThis overlap can cause confusion unless the data types are clearly and correctly defined.\nPage 12\n255\n0\n-128\n0\n+127",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 19,
      "text": "Chapter  3.0 ► Data Representation\n 3.1.1 Two's Complement\nThe following describes how to find the two's complement representation for negative \nvalues.\nTo take the two's complement of a number:\n1. Take the one's complement (negate)\n2. Add 1 (in binary)\nThe same process is used to encode a decimal value into two's complement and from \ntwo's complement back to decimal.  The following sections provide some examples.\n 3.1.2 Byte Example\nFor example, to find the byte size, two's complement representation of -9 and -12.\n9 (8+1) =\n00001001\n12 (8+4) =\n00001100\nStep 1\n11110110\nStep 1:\n11110011\nStep 2\n11110111\n11110100\n-9 (in hex) =\n  F7\n-12 (in hex) =\n  F4\nNote, all bits for the given size, byte in this example, must be specified.\n 3.1.3 Halfword Example\nTo find the halfword size, two's complement representation of -18 and -40.\n18 (16+2) =\n0000000000010010\n40 (32+8) =\n0000000000101000\nStep 1  \n1111111111101101\nStep 1  \n1111111111010111\nStep 2  \n1111111111101110\nStep 2  \n1111111111011000\n-18 (hex) =\nFFEE\n-40 (hex) =\nFFD8\nNote, all bits for the given size, halfwords in these examples, must be specified.\nPage 13",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 20,
      "text": "Chapter 3.0 ◄ Data Representation\n 3.2 Unsigned and Signed Addition\nAs previously noted, the unsigned and signed representations may provide different \ninterpretations for the final value being represented.  However, the addition and \nsubtraction operations are the same.  For example:\n241\n11110001\n-15\n11110001\n+\n7\n00000111\n+\n7\n00000111\n248\n11111000\n-8\n11111000\n248  = \n  F8\n-8  = \n  F8\nThe final result of 0xF8 may be interpreted as 248 for unsigned representation and -8 for\na signed representation.\nAdditionally, 0xF816 is the º (degree symbol) in the ASCII table.\nAs such, it is very important to have a clear definition of the sizes (byte, halfword, word,\netc.) and types (signed, unsigned) of data for the operations being performed.\n 3.3 Floating-point Representation\nThe representation issues for floating-point numbers are more complex.  There are a \nseries of floating-point representations for various ranges of the value.  For simplicity, \nwe will only look primarily at the IEEE 754 32-bit floating-point standard.\n 3.3.1 IEEE 32-bit Representation\nThe IEEE 754 32-bit floating-point standard is defined as follows:\n31\n30\n29\n28\n27\n26\n25\n24\n23\n22\n21\n20\n19\n18\n17\n16\n15\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\ns\nbiased exponent\nfraction\nWhere s is the sign (0 => positive and 1 => negative).  When representing floating-point\nvalues, the first step is to convert floating-point value into binary.\nPage 14",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 21,
      "text": "Chapter  3.0 ► Data Representation\nThe following table provides a brief reminder of how binary handles fractional \ncomponents:\n23\n22\n21\n20\n2-1\n2-2\n2-3\n...\n8\n4\n2\n1\n.\n1/2\n1/4\n1/8\n...\n0\n0\n0\n0\n.\n0\n0\n0\nFor example, 100.1012 would be 4.62510.  For repeating decimals, calculating the binary \nvalue can be time consuming.  However, there is a limit since computers have finite \nstorage.\nThe next step is to show the value in binary normalized scientific notation.  This means \nthat the normalized number should have a single, non-zero leading digit to the left of the\ndecimal point.  For example, 8.12510 is 1000.0012 (or 1000.0012 x 20) and in binary \nnormalized scientific notation it would be written as 1.000001 x 23 (since the decimal \npoint was moved three places to the left).  Of course, if the number was 0.12510 the \nbinary would be 0.0012 (or 0.0012 x 20) and the normalized scientific notation would be \n1.0 x 2-3 (since the decimal point was moved three places to the right).  The numbers \nafter the leading 1, not including the leading 1, are stored left-justified in the fraction \nportion of the word.\nThe next step is to calculate the biased exponent, which is the exponent from the \nnormalized scientific notation plus the defined bias.  The bias for the IEEE 754 32-bit \nfloating-point standard is 12710.  The result should be converted to a byte (8 bits) and \nstored in the biased exponent portion of the word.\nNote, converting from the IEEE 754 32-bit floating-point representation to the decimal \nvalue is done in reverse, however the leading 1 must be added back (as it is not stored in\nthe word).  Additionally, the bias is subtracted (instead of added).\n 3.3.1.1 IEEE 32-bit Representation Examples\nThis section presents several examples of encoding and decoding floating-point \nrepresentation for reference.\nPage 15",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 22,
      "text": "Chapter 3.0 ◄ Data Representation\n 3.3.1.1.1 Example → -7.7510\nFor example, to find the IEEE 754 32-bit floating-point representation for -7.7510:\nExample 1:\n-7.75\n•\ndetermine sign\n-7.75  =>  1 (since negative)\n•\nconvert to binary\n-7.75\n=\n-0111.112\n•\nnormalized scientific notation\n=\n1.1111 x 22\n•\ncompute biased exponent\n210 + 12710  =  12910 \n◦\nand convert to binary\n =  100000012\n•\nwrite components in binary:\nsign  exponent   mantissa\n   1   10000001  11110000000000000000000\n•\nconvert to hex (split into groups of 4)\n   11000000111110000000000000000000\n   1100 0000 1111 1000 0000 0000 0000 0000\n      C       0       F       8       0       0        0       0\n•\nfinal result:\nC0F8 000016\n 3.3.1.1.2 Example → -0.12510\nFor example, to find the IEEE 754 32-bit floating-point representation for -0.12510:\nExample 2:\n-0.125\n•\ndetermine sign\n-0.125  =>  1 (since negative)\n•\nconvert to binary\n-0.125\n=\n-0.0012\n•\nnormalized scientific notation\n=\n1.0 x 2-3\n•\ncompute biased exponent\n-310  +  12710  =  12410 \n◦\nand convert to binary\n =  011111002\n•\nwrite components in binary:\nsign  exponent   mantissa\n   1   01111100  00000000000000000000000\n•\nconvert to hex (split into groups of 4)\n   10111110000000000000000000000000\n   1011 1110 0000 0000 0000 0000 0000 0000\n      B       E       0       0       0       0        0       0\n•\nfinal result:\nBE00 000016\nPage 16",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 23,
      "text": "Chapter  3.0 ► Data Representation\n 3.3.1.1.3 Example → 4144000016\nFor example, given the IEEE 754 32-bit floating-point representation 4144000016 find \nthe decimal value:\nExample 3:\n4144000016\n•\nconvert to binary\n   0100 0001 0100 0100 0000 0000 0000 00002\n•\nsplit into components\n   0 10000010 100010000000000000000002\n•\ndetermine exponent\n \n100000102  =  13010 \n◦\nand remove bias\n13010 - 12710  =  310\n•\ndetermine sign\n0 =>  positive\n•\nwrite result\n+1.10001 x 23 = +1100.01 = +12.25\n 3.3.2 IEEE 64-bit Representation\nThe IEEE 754 64-bit floating-point standard is defined as follows:\n63\n62\n52\n51\n0\ns\nbiased exponent\nfraction\nThe representation process is the same, however the format allows for an 11-bit biased \nexponent (which support large and smaller values).  The 11-bit biased exponent uses a \nbias of 1023.\nPage 17",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 24,
      "text": "Chapter 3.0 ◄ Data Representation\nPage 18",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 25,
      "text": "4.0\nQtSpim Program Formats\nThe QtSpim MIPS simulator will be used for programs in this text.  The QtSpim \nsimulator has a number of features and requirements for writing MIPS assembly \nlanguage programs.  This includes a properly formatted assembly source file.\nA properly formatted assembly source file consists of two main parts; the data section \n(where data is placed) and the text section (where code is placed).  The following \nsections summarize the formatting requirements and explain each of these sections.\n 4.1 Assembly Process\nThe QtSpim effectively assembles the program during the load process.  Any major \nerrors in the program format or the instructions will be noted immediately.  Assembler \nerrors must be resolved before the program can be successfully executed.  Refer to \nAppendix B regarding the use of QtSpim to load and execute programs.\n 4.2 Comments\nThe \"#\" character represents a comment line.  Anything typed after the \"#\" is considered\na comment.  Blank lines are accepted.\n 4.3 Assembler Directives\nAn assembler directive is a message to the assembler, or the QtSpim simulator, that tells\nthe assembler something it needs to know in order to carry out the assembly process.  \nThis includes noting where the data is declared or the code is defined.  Assembler \ndirectives are not executable statements.\nAssembler directives start with a \".\".  Assembler directives are required to define the \nstart and end of data declarations and to define the start and end of procedures/functions.\nFor example, \".data\" or \".text\".\nAdditionally, directives are used to declare data.  The following sections provide some \nexamples of data declarations using the directives.\nPage 19",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.65 sec"
    },
    {
      "page_number": 26,
      "text": "Chapter 4.0 ◄ QtSpim Program Formats\n 4.4 Data Declarations\nThe data must be declared in the \".data\" section.  All variables and constants are placed \nin this section.  Variable names must start with a letter followed by letters or numbers \n(including some special characters such as the \"_\"), and terminated with a \":\" (colon).  \nVariable definitions must include the name, the data type, and the initial value for the \nvariable.   In the definition, the variable name must be terminated with a \":\".\nThe data type must be preceded with a \".\" (period).  The general format is:\n<variableName>:\n.<dataType>\n<initialValue>\nRefer to the following sections for a series of examples using various data types.\nThe supported data types are as follows:\nDeclaration\n.byte\n8-bit variable(s)\n.half\n16-bit variable(s)\n.word\n32-bit variable(s)\n.ascii\nASCII string\n.asciiz\nNULL terminated ASCII string\n.float\n32 bit IEEE floating-point number\n.double\n64 bit IEEE floating-point number\n.space <n>\n<n> bytes of uninitialized memory\nThese are the primary assembler directives for data declaration. Other directives are \nreferenced in different sections.\n 4.4.1 Integer Data Declarations\nInteger values are defined with the  .word,  .half, or  .byte directives.  Two's complement\nis used for the representation of negative values.  For more information regarding two's \ncomplement, refer to the Data Representation section.\nPage 20",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 27,
      "text": "Chapter  4.0 ► QtSpim Program Formats\nThe following declarations are used to define the integer variables \"wVar1\" and \n\"wVar2\" as 32-bit word values and initialize them to 500,000 and -100,000.\nwVar1:\n.word\n500000\nwVar2:\n.word\n-100000\nThe following declarations are used to define the integer variables \"hVar1\" and \"hVar2\" \nas 16-bit word values and initialize them to 5,000 and -3,000.\nhVar1:\n.half\n5000\nhVar2:\n.half\n-3000\nThe following declarations are used to define the integer variables \"bVar1\" and \"bVar2\" \nas 8-bit word values and initialize them to 5 and -3.\nbVar1:\n.byte\n5\nbVar2:\n.byte\n-3\nIf a variable is initialized to a value that can not be stored in the allocated space, an \nassembler error will be generated.  For example, attempting to set a byte variable to 500 \nwould be illegal and generate an error.\n 4.4.2 String Data Declarations\nAt the assembly level, a string is a series of sequentially defined byte-sized characters, \ntypically terminated with a NULL byte (0x00).\nStrings are defined with  .ascii  or  .asciiz  directives.  Characters are represented using \nstandard ASCII characters.  Refer to Appendix D for a copy of the ASCII table for \nreference.\nThe C/C++ style new line, \"\\n\", and tab, \"\\t\" tab are supported within strings.\nThe following declarations are used to define a string \"message\" and initialize it to \n\"Hello World\".\nmessage:\n.asciiz\n\"Hello World\\n\"\nIn this example, the string is defined as NULL terminated (i.e., after the new line).  The \nNULL is a non-printable ASCII character and is used to mark the end of the string.  The \nNULL termination is standard and is required by the print string system service (to work\ncorrectly).\nPage 21",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 28,
      "text": "Chapter 4.0 ◄ QtSpim Program Formats\nTo define a string with multiple lines, the NULL termination would only be required on \nthe final or last line.  For example:\nmessage:\n.ascii\n\"Line 1: Goodbye World\\n\"\n.ascii\n\"Line 2: So, long and thanks \"\n.ascii\n\"for all the fish.\\n\"\n.asciiz\n\"Line 3: Game Over.\\n\"\nWhen printed, using the starting address of 'message', everything up-to (but not \nincluding) the NULL will be displayed.  As such, the declaration using multiple lines is \nnot relevant to the final displayed output.\n 4.4.3 Floating-Point Data Declarations\nFloating-point values are defined with the  .float  (32-bit) or  .double  (64-bit) directives.\nThe IEEE floating-point format is used for the internal representation of floating-point \nvalues.\nThe following declarations are used to define the floating-point variables \"pi\" a 32-bit \nfloating-point value initialized to 3.14159 and \"tao\" a 64-bit floating-point values \ninitialized them to 6.28318.\npi:\n.float\n3.14159\ntao:\n.double\n6.28318\nFor more information regarding the IEEE format, refer to the Data Representation \nsection.\n 4.5 Constants\nConstant names must start with a letter, followed by letters or numbers including some \nspecial characters such as the \"_\" (underscore).  Constant definitions are created with an \n\"=\" sign.\nFor example, to create some constants named TRUE and FALSE and set them to 1 and \n0 respectively:\nTRUE = 1 \nFALSE = 0\nConstants are also defined in the data section.  The use of all capitals for a constant is a \nconvention and not required by the QtSpim program.  The convention helps \nprogrammers more easily distinguish between variables (which can change values) and \nPage 22",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 29,
      "text": "Chapter  4.0 ► QtSpim Program Formats\nconstants (which can not change values).  Additionally, in assembly language constants \nare not typed (i.e., not predefined to be a specific size such as 8-bits, 16-bits, 32-bits, or \n64-bits).\n 4.6 Program Code\nThe code must be preceded by the \".text\" directive.\nIn addition, there are some basic requirements for naming a \"main\" procedure (i.e., the \nfirst procedure to be executed).  The \".globl name\" and \".ent name\" directives are used \nto define the name of the initial or main procedure. The \".ent\" is optional for the QtSpim\nsimulator.  Note, the globl spelled incorrectly is the correct directive.  Also, the main \nprocedure must start with a label with the procedure name.  The main procedure (as all \nprocedures) should be terminated with the \".end <name>\" directive.\nIn the program template, the <name> would be the name of the main \nfunction/procedure, which is \"main\".\n 4.7 Labels\nLabels are code locations, typically used as a function/procedure name or as the target of\na jump.  The first use of a label is the main program starting location, which must be \nnamed 'main' which is a specific requirement for the QtSpim simulator.\nThe rules for a label are as follows:\n•\nMust start with a letter\n•\nMay be followed by letters, numbers, or an \"_\" (underscore).\n•\nMust be terminated with a \":\" (colon).\n•\nMay only be defined once.\nSome examples of a label include:\nmain:\nexitProgram:\nCharacters in a label are case-sensitive.  As such, Loop: and loop: are different labels.\nThis can be very confusing initially, so caution is advised.\nPage 23",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 30,
      "text": "Chapter 4.0 ◄ QtSpim Program Formats\n 4.8 Program Template\nThe following is a very basic template for QtSpim MIPS programs.  This general \ntemplate will be used for all programs.\n#  Name and general description of program\n# ----------------------------------------\n#  Data declarations go in this section.\n.data\n#\nprogram specific data declarations\n# ----------------------------------------\n#  Program code goes in this section.\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#\nyour program code goes here.\n# -----\n#  Done, terminate program.\nli\n$v0, 10\nsyscall\n# all done!\n.end\nmain\nThe initial header (\".text\", \".globl main\", \".ent main\", and \"main:\") will be the same for \nall QtSpim programs.  The final instructions (\"li $v0, 10\" and \"syscall\") terminate the \nprogram.\nA more complete example, with working code, can be found in Appendix A.\nPage 24",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 31,
      "text": "5.0\nInstruction Set Overview\nIn assembly-language, instructions are how work is accomplished.  In assembly the \ninstructions are simple, single operation commands.  In a high-level language, one line \nmight be translated into a series of instructions in assembly-language.\nThis chapter presents a summary of the basic, most common instructions.  The MIPS \nInstruction Set Appendix presents a more comprehensive list of the available \ninstructions.\n 5.1 Pseudo-Instructions vs Bare-Instructions\nAs part of the MIPS architecture, the assembly language includes a number of pseudo-\ninstructions.  A bare-instruction is an instruction that is directly executed by the CPU.  \nA pseudo-instruction is an instruction that the assembler, or simulator, will recognize \nbut then convert into one or more bare-instructions.  This text will focus primarily on \nthe pseudo-instructions.\n 5.2 Notational Conventions\nThis section summarizes the notation used within this text which is fairly common in the\ntechnical literature.  In general, an instruction will consist of the instruction or operation \nitself (i.e., add, sub, mul, etc.) and the operands.  The operands refer to where the data \n(to be operated on) is coming from, or where the result is to be placed.\nThe following table summarizes the notational conventions used in the remainder of the \ndocument.\nOperand Notation\nDescription\nRdest\nDestination operand.  Must be an integer register.  \nSince it is a destination operand, the contents will be \nover written with the new result.\nRsrc\nSource operand.  Must be an integer register.  \nRegister value is unchanged after the instruction.\nPage 25",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 32,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nSrc\nSource operand.  Must be an integer register or an \ninteger immediate value.  Value is unchanged after \nthe instruction.\nFRdest\nDestination operand.  Must be a floating-point \nregister.  Since it is a destination operand, the \ncontents will be overwritten with the new result.\nFRsrc\nSource operand.  Must be a floating-point register.  \nRegister value is unchanged after the instruction.\nImm\nImmediate value.\nMem\nMemory location.  May be a variable name or an \nindirect reference (i.e., a memory address).\nBy default, the immediate values are decimal or base-10.  Hexadecimal or base-16 \nimmediate values may be used but must be preceded with a 0x to indicate the value is \nhex.  For example, 1510 could be entered in hex as 0x0F.\nRefer to the chapter on Addressing Modes for more information regarding memory \nlocations and indirection.\n 5.3 Data Movement\nCPU computations are typically performed using registers.  As such, before \ncomputations can be performed, data is typically moved into registers from variables \n(i.e., memory) and when the computations are completed the data would be moved out \nof registers into other variables.\n 5.3.1 Load and Store\nTo support the loading of data from memory (e.g., variables or arrays) into registers and \nstoring of data in register back to memory, there are a series of load and store \ninstructions.  The load and store instructions only move data between register and \nmemory.  Another instruction is used to move data between registers (as described in the\nnext section).\nThere are no load or store instructions that will move a value from a memory location \ndirectly to another memory location.\nPage 26",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 33,
      "text": "Chapter  5.0 ► Instruction Set Overview\nThe general forms of the load and store instructions are as follows:\nInstruction\nDescription\nl<type>\nRdest, mem\nLoad value from memory location \ninto destination register.\nli\nRdest, imm\nLoad specified immediate value \ninto destination register.\nla\nRdest, mem\nLoad address of memory location \ninto destination register.\ns<type>\nRsrc, mem\nStore contents of source register \ninto memory location.\nAssuming the following data declarations:\nnum:\n.word\n0\nwnum:\n.word\n42\nhnum:\n.half\n73\nbnum:\n.byte\n7\nwans:\n.word\n0\nhans:\n.half\n0\nbans:\n.byte\n0\nTo perform, the basic operations of:\nnum = 27\nwans = wnum\nhans = hnum\nbans = bnum\nThe following instructions could be used:\nli\n$t0, 27\nsw\n$t0, num\n# num = 27\nlw\n$t0, wnum\nsw\n$t0, wans\n# wans = wnum\nlh\n$t1, hnum\nsh\n$t1, hans\n# hans = hnum\nlb\n$t2, bnum\nsb\n$t2, bans\n# bans = bnum\nPage 27",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 34,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nFor the halfword and byte instructions, only the lower 16-bits or the lower 8-bits are \nused.\n 5.3.2 Move\nThe various forms of the move instructions are used to move data between registers.  \nBoth operands must be registers.  The most basic move instruction, move, copies the \ncontents of an integer register into another integer register.  Another set of move \ninstructions are used to move the contents of registers into or out of the special registers,\n$hi and $lo.\nIn addition, different move instructions are required to move values between integer \nregisters and floating-point registers (as discussed on the floating-point section).\nThere is no move instruction that will move a value from a memory location directly to \nanother memory location.\nThe general forms of the move instructions are as follows:\nInstruction\nDescription\nmove\nRdest, RSrc\nCopy contents of integer source \nregister into integer destination \nregister.\nmfhi\nRdest\nCopy the contents from the $hi \nregister into Rdest register.\nmflo\nRdest\nCopy the contents from the $lo \nregister into Rdest register.\nmthi\nRdest\nCopy the contents to the $hi \nregister from the Rdest register.\nmtlo\nRdest\nCopy the contents to the $lo register\nfrom the Rdest register.\nFor example, the following instructions:\nli\n$t0, 42\nmove\n$t1, $t0\nwill move the contents of register $t0, 42 in this example, into the $t1 register.\nPage 28",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.66 sec"
    },
    {
      "page_number": 35,
      "text": "Chapter  5.0 ► Instruction Set Overview\nThe mfhi, mflo, mtho, and mtlo instructions are required only when performing 64-bit \ninteger multiply and divide operations.\nThe floating-point section will include examples for moving data between integer and \nfloating-point registers.\n 5.4 Integer Arithmetic Operations\nThe arithmetic operations include addition, subtraction, multiplication, division, \nremainder (remainder after division), logical AND, and logical OR.  The general format \nfor these basic instructions is as follows:\nInstruction\n   Description\nadd      Rdest, Rsrc, Src\nSigned addition\nRdest = Rsrc + Src or Imm\naddu     Rdest, Rsrc, Src\nUnsigned addition\nRdest = Rsrc + Src or Imm\nsub      Rdest, Rsrc, Src\nSigned subtraction\nRdest = Rsrc – Src or Imm\nsubu     Rdest, Rsrc, Src\nUnsigned subtraction\nRdest = Rsrc – Src or Imm\nmul      Rdest, Rsrc, Src\nSigned multiply with no overflow\nRdest = Rsrc * Src or Imm\nmulo     Rdest, Rsrc, Src\nSigned multiply with overflow\nRdest = Rsrc * Src or Imm\nmulou    Rdest, Rsrc, Src\nUnsigned multiply with overflow\nRdest = Rsrc * Src or Imm\nmult     Rsrc1, Rsrc2\nSigned 64-bit multiply\n$hi/$lo = Rsrc1 * Rsrc2\nmultu    Rsrc1, Rsrc2\nUnsigned 64-bit multiply\n$hi/$lo = Rsrc1 * Rsrc2\ndiv      Rdest, Rsrc, Src\nSigned divide\nRdest = Rsrc / Src or Imm\nPage 29",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.67 sec"
    },
    {
      "page_number": 36,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\ndivu     Rdest, Rsrc, Src\nUnsigned divide\nRdest = Rsrc / Src or Imm\ndiv      Rsrc1, RSrc2\nSigned divide with remainder\n$lo = Rsrc1 / RSrc2\n$hi = Rsrc1 % RSrc2\ndivu     Rsrc1, RSrc2\nUnsigned divide with remainder\n$lo = Rsrc1 / RSrc2\n$hi = Rsrc1 % RSrc2\nrem      Rdest, Rsrc, Src\nSigned remainder\nRdest = Rsrc % Src or Imm\nremu     Rdest, Rsrc, Src\nUnsigned remainder\nRdest = Rsrc % Src or Imm\nabs      Rdest, Rsrc\nAbsolute value\nRdest = | Rsrc |\nneg      Rdest, Rsrc\nSigned negation\nRdest = - Rsrc\nThese instructions operate on 32-bit registers (even if byte or halfword values are placed\nin the registers).\nAssuming the following data declarations:\nwnum1:\n.word\n651\nwnum2:\n.word\n42\nwans1:\n.word\n0\nwans2:\n.word\n0\nwans3:\n.word\n0\nhnum1:\n.half\n73\nhnum2:\n.half\n15\nhans:\n.half\n0\nbnum1:\n.byte\n7\nbnum2:\n.byte\n9\nbans:\n.byte\n0\nPage 30",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.67 sec"
    },
    {
      "page_number": 37,
      "text": "Chapter  5.0 ► Instruction Set Overview\nTo perform, the basic operations of:\nwans1 = wnum1 + wnum2\nwans2 = wnum1 * wnum2\nwans3 = wnum1 % wnum2\nhans  = hnum1 * hnum2\nbans  = bnum1 / bnum2\nThe following instructions could be used:\nlw\n$t0, wnum1\nlw\n$t1, wnum2\nadd\n$t2, $t0, $t1\nsw\n$t2, wans1\n# wans1 = wnum1 + wnum2\nlw\n$t0, wnum1\nlw\n$t1, wnum2\nmul\n$t2, $t0, $t1\nsw\n$t2, wans2\n# wans2 = wnum1 * wnum2\nlw\n$t0, wnum1\nlw\n$t1, wnum2\nrem\n$t2, $t0, $t1\nsw\n$t2, wans3\n# wans = wnum1 % wnum2\nlh\n$t0, hnum1\nlh\n$t1, hnum2\nmul\n$t2, $t0, $t1\nsh\n$t2, hans\n# hans = hnum1 * hnum2\nlb\n$t0, bnum1\nlb\n$t1, bnum2\ndiv\n$t2, $t0, $t1\nsb\n$t2, bans\n# bans = bnum1 / bnum2\nFor the halfword load or store instructions, only the lower 16-bits are used.  For the byte\ninstructions, only the lower 8-bits are used.\nPage 31",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "11.67 sec"
    },
    {
      "page_number": 38,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\n 5.4.1 Example Program, Integer Arithmetic\nThe following is an example program to compute the\nvolume and surface area of a rectangular parallelepiped. \nThe formulas for the volume and surface area are as\nfollows:\nvolume = aSide∗bSide∗cSide\nsurfaceArea = 2( aSide∗bSide + aSide∗cSide + bSide∗cSide)\nThis example main initializes the a, b, and c sides to arbitrary integer values.\n#  Example to compute the volume and surface area\n#  of a rectangular parallelepiped.\n# -----------------------------------------------------\n#  Data Declarations\n.data\naSide:\n.word\n73\nbSide:\n.word\n14\ncSide:\n.word\n16\nvolume:\n.word\n0\nsurfaceArea:\n.word\n0\n# -----------------------------------------------------\n#  Text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Load variables into registers.\nlw\n$t0, aSide\nlw\n$t1, bSide\nlw\n$t2, cSide \nPage 32",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page38_img1.png"
      ],
      "img_summary_files": [],
      "img_vision_files": [
        "output\\images\\img_vision\\MIPS_Assembly_Language_small_163_page38_img1_vision.json"
      ],
      "time_taken": "18.76 sec"
    },
    {
      "page_number": 39,
      "text": "Chapter  5.0 ► Instruction Set Overview\n# ---- \n#  Find volume of a rectangular parallelpiped.\n#\nvolume = aSide * bSide * cSide \nmul\n$t3, $t0, $t1\nmul\n$t4, $t3, $t2\nsw\n$t4, volume\n# -----\n#  Find surface area of a rectangular parallelepiped.\n#     surfaceArea = 2*(aSide*bSide+aSide*cSide+bSide*cSide)\nmul\n$t3, $t0, $t1\n# aSide * bSide\nmul\n$t4, $t0, $t2\n# aSide * cSide\nmul\n$t5, $t1, $t2\n# bSide * cSide\nadd\n$t6, $t3, $t4 \nadd\n$t7, $t6, $t5\nmul\n$t7, $t7, 2\nsw\n$t7, surfaceArea\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# call code for terminate\nsyscall\n# system call (terminate)\n.end main\nRefer to the system services section for information on displaying the final results to the \nconsole.\n 5.5 Logical Operations\nThe logical operations include logical AND, logical OR, shift, and rotate instructions.  \nThe general format for these instructions is as follows:\nInstruction\n   Description\nand       Rdest, Rsrc, Src\nLogical AND\nRdest = Rsrc & Src or Imm\nnor       Rdest, Rsrc, Src\nLogical NOR\nRdest = Rsrc ↓ Src or Imm\nPage 33",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.76 sec"
    },
    {
      "page_number": 40,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nnot       Rdest, Rsrc, Src\nLogical NOT\nRdest = Rsrc ¬ Src or Imm\nor        Rdest, Rsrc, Src\nLogical OR\nRdest = Rsrc | Src or Imm\nrol       Rdest, Rsrc, Src\nRotate left\nRdest = Rsrc rotated left Src\n              or Imm places\nror       Rdest, Rsrc, Src\nRotate right\nRdest = Rsrc rotated right Src\n              or Imm places\nsll       Rdest, Rsrc, Src\nShift left logical\nRdest = Rsrc shift left logical\n              Src or Imm places\nsra       Rdest, Rsrc, Src\nShift right arithmetic\nRdest = Rsrc shift right\n              arithmetic Src or\n              Imm places\nsrl       Rdest, Rsrc, Src\nShift right logical\nRdest = Rsrc shift right logical\n              Src or Imm places\nxor       Rdest, Rsrc, Src\nLogical XOR\nRdest = Rsrc ^ Src or Imm\nThe & refers to the logical AND operation, the | refers to the logical OR operation, and \nthe ^ refers to the logical XOR operation as per C/C++ conventions.   The ↓ refers to the\nlogical NOR operation and the ¬ refers to the logical NOT operation.\nThese instructions operate on 32-bit registers (even if byte or halfword values are placed\nin the registers).\nAssuming the following data declarations:\nwnum1:\n.word\n0x000000ff\nwnum2:\n.word\n0x0000ff00\nwans1:\n.word\n0\nwans2:\n.word\n0\nwans3:\n.word\n0\nPage 34",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 41,
      "text": "Chapter  5.0 ► Instruction Set Overview\nTo perform, the basic operations of:\nwans1 = wnum1 & wnum2\nwans2 = wnum1 | wnum2\nwans3 = wnum1 ¬ wnum2\nThe following instructions \nlw\n$t0, wnum1\nlw\n$t1, wnum2\nand\n$t2, $t0, $t1\nsw\n$t2, wans1\n# wans1 = wnum1 & wnum2\nlw\n$t0, wnum1\nlw\n$t1, wnum2\nor\n$t2, $t0, $t1\nsw\n$t2, wans2\n# wans2 = wnum1 | wnum2\nlw\n$t0, wnum1\nlw\n$t1, wnum2\nnot\n$t2, $t0, $t1\nsw\n$t2, wans3\n# wans3 = wnum1 ¬ wnum2\nFor halfword load or store instructions, only the lower 16-bits are used.  For the byte \ninstructions, only the lower 8-bits are used.\n 5.5.1 Shift Operations\nThe shift operations shift or move bits within a register.  Two typical reasons for shifting\nbits include isolating a subset of the bits within an operand for some specific purpose or \npossibly for performing multiplication or division by powers of two.  The two shift \noperations are a logical shift and an arithmetic shift.\nPage 35",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 42,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\n 5.5.1.1 Logical Shift\nThe logical shift is a bitwise operation that shifts all the bits of its source register by the \nspecified number of bits and places the result into the destination register.  The bits can \nbe shifted left or right as needed.  Every bit in the source operand is moved the specified\nnumber of bit-positions, and the newly vacant bit-positions are filled in with zeros.  The \nfollowing diagram shows how the right and left shift operations work for byte sized \noperands.\nShift Right Logical\nShift Left Logical\n7\n6\n5\n4\n3\n2\n1\n0\n7\n6\n5\n4\n3\n2\n1\n0\n1\n0\n1\n1\n0\n0\n1\n1\n1\n0\n1\n1\n0\n0\n1\n1\n0\n0\n1\n0\n1\n1\n0\n0\n1\n0\n1\n1\n0\n0\n1\n1\n0\n0\nThe logical shift treats the operand as a sequence of bits rather than as a number.\nThe shift instructions may be used to perform unsigned integer multiplication and \ndivision operations for powers of 2.  Powers of two would be 2, 4, 8, etc. up to the limit \nof the operand size (32-bits for register operands).\nIn the examples below, 23 is divided by 2 by performing a shift right logical one bit. \nThe resulting 11 is shown in binary.  Next, 13 is multiplied by 4 by performing a shift \nleft logical two bits.  The resulting 52 is shown in binary.\nShift Right Logical\nUnsigned Division\nShift Left Logical\nUnsigned Multiplication\n0\n0\n0\n1\n0\n1\n1\n1\n=  23\n0\n0\n0\n0\n1\n1\n0\n1\n=\n13\n0\n0\n0\n0\n1\n0\n1\n1\n=  11\n0\n0\n1\n1\n0\n1\n0\n0\n=\n52\nAs can be seen in the examples, a 0 was entered in the newly vacated bit locations on \neither the right or left (depending on the operation).\nPage 36",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 43,
      "text": "Chapter  5.0 ► Instruction Set Overview\n 5.5.1.2 Arithmetic Shift\nThe arithmetic shift right is also a bitwise operation.  This instruction shifts all bits of \nthe source register by the specified number of bit-positions and places the result into the \ndestination register.  Every bit in the source operand is moved the specified number of \nbit-positions, and the newly vacant bit-positions on the left are filled in.  The original \nleftmost bit (the sign bit) is replicated to fill in all the vacant positions.  This is referred \nto as sign extension.  The following diagram shows how the shift right arithmetic \noperations work for a byte sized operand.\nShift Right Arithmetic\n7\n6\n5\n4\n3\n2\n1\n0\n1\n0\n1\n1\n0\n0\n1\n1\n1\n1\n0\n1\n1\n0\n0\n1\nThe arithmetic shift treats the operand as a signed number and extends the sign which \nwould be negative in this example.\nHowever, the arithmetic shift rounds up and the standard divide instruction truncates.  \nAs such, the arithmetic shift is not typically used to replace the signed divide instruction.\n 5.5.1.3 Shift Operations, Examples\nThis section provides a series of examples using the logical shift operations.\nAssuming the following data declarations:\ndata1:\n.word\n0x000000ff\nresult1:\n.word\n0\nresult2:\n.word\n0\nTo perform, the basic operations of:\nresult1 = wnum1, rotate left 1 bit\nresult2 = wnum1, rotate right 1 bit\nPage 37",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 44,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nThe following instructions \nlw\n$t0, wnum1\nlw\n$t1, wnum2\nrol\n$t2, $t0, $t1\nsw\n$t2, wans3\n# wans3 = wnum1, rotate left 1 bit\nlw\n$t0, wnum1\nlw\n$t1, wnum2\nror\n$t2, $t0, $t1\nsw\n$t2, wans4\n# wans3 = wnum1, rotate right 1 bit\nFor halfword instructions, only the lower 16-bits are used.  For the byte instructions, \nonly the lower 8-bits are used.\nTo perform the operation, value * 8, it would be possible to shift the number in the \nvariable one bit for each power of two, which would be three bits in this example.\nAssuming the following data declarations:\nvalue:\n.word\n17\nanswer:\n.word\n0\nThe following instructions could be used to multiply a value by 8.\nlw\n$t0, value\nsll\n$t1, $t0, 3\nsw\n$t1, answer\n# answer = value * 8\nThe final value in answer would be 17 * 8 or 136.\nIn the context of an encoded MIPS instruction, the upper 6-bits of a 32-bit word \nrepresent the OP or operation field.  If a program was analyzing code, it might be \ndesirable to isolate these bits for comparison.  One way this can be performed is to use a\nlogical right shift to move the upper six bits into the position of the lower 6-bits.\nThe instruction:\nadd\n$t1, $t1, 1\nwill be translated by the assembler into the hex value of 0x2129001.\nAssuming the following data declarations:\ninst1:\n.word\n0x2129001\ninst1Op1:\n.word\n0\nPage 38",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 45,
      "text": "Chapter  5.0 ► Instruction Set Overview\nTo mask out the OP field (upper 6-bits) for inst1 and place it in the variable instOp1 \n(lower 6-bits), the following instructions could be used:\nlw\n$t0, inst1\nsrl\n$t1, $t0, 26\nsw\n$t1, instOp1\nThis can be done in one step since the logical shift will insert all 0's into the newly \nvacated bit locations.\n 5.6 Control Instructions\nProgram control refers to basic programming structures for iteration and comparisons \nsuch as IF statements and looping.  All of the high-level language control structures \nmust be  performed with the limited assembly-language control structures.  For example,\nan IF-THEN-ELSE statement does not exist at the assembly-language level.  Assembly-\nlanguage provides an unconditional branch (or jump), and a conditional branch or an IF \nstatement that will jump to a target label or not jump (as per the conditional expression).\nThe control instructions refer to unconditional and conditional branching.  Branching is \nrequired for basic conditional statements (i.e., IF statements) and looping.\n 5.6.1 Unconditional Control Instructions\nThe unconditional instruction provides an unconditional jump to a specific location.\nInstruction\nDescription\nj <label>\nUnconditionally branch to the \nspecified label.\nThe \"b\" (branch) may be used instead of the \"j\" (jump).  Both are encoded as the same \ninstruction (an unconditional jump).  An error is generated by QtSpim if the label is not \ndefined.\n 5.6.2 Conditional Control Instructions\nThe conditional instruction provides a conditional jump based on a comparison.  In \nhigh-level language terms, this is a basic IF statement.\nPage 39",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 46,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nThe conditional control instructions include the standard set; branch equal, branch not \nequal, branch less than, branch less than or equal, branch greater than, and branch \ngreater than or equal.\nThe general format for these basic instructions is as follows:\nInstruction\n  Description\nbeq <Rsrc>, <Src>, <label>\n  Branch to label if <Rsrc> and\n  <Src> are equal\nbne <Rsrc>, <Src>, <label>\n  Branch to label if <Rsrc> and\n  <Src> are not equal\nblt <Rsrc>, <Src>, <label>\n  Signed branch to label if <Rsrc>\n  is less than <Src> \nble <Rsrc>, <Src>, <label>\n  Signed branch to label if <Rsrc>\n  is less than or equal to <Src> \nbgt <Rsrc>, <Src>, <label>\n  Signed branch to label if <Rsrc>\n  is greater than <Src> \nbge <Rsrc>, <Src>, <label>\n  Signed branch to label if <Rsrc>\n  is greater than or equal to <Src> \nbltu <Rsrc>, <Src>, <label>\n  Unsigned branch to label if <Rsrc>\n  is less than <Src> \nbleu <Rsrc>, <Src>, <label>\n  Unsigned branch to label if <Rsrc>\n  is less than or equal to <Src> \nbgtu <Rsrc>, <Src>, <label>\n  Unsigned branch to label if <Rsrc>\n  is greater than <Src> \nbgeu <Rsrc>, <Src>, <label>\n  Unsigned branch to label if <Rsrc>\n  is greater than or equal to <Src> \nThese instructions operate on 32-bit registers (even if byte or halfword values are placed\nin the registers). \nIn addition, these conditional control instructions can be modified by adding or \nappending a ‘z’ to the end which means a comparison to zero (0) without typing the \nimmediate 0 in the instruction.\nPage 40",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 47,
      "text": "Chapter  5.0 ► Instruction Set Overview\nFor example, the following instruction,\nbne\n $t0, 0, loop1\ncould be written as,\nbnez\n $t0, loop1\nwhich does exactly the same thing.  This short-handed method is used in some of the \ntext examples.  A more complete list is included in Appendix C.\n 5.6.3 Example Program, Sum of Squares\nThe following is an example program to find the sum of squares from 1 to n.  For \nexample, the sum of squares from 1 to 10 is as follows:\n12 22 ⋯102 = 385\nThis example program initializes the n to 10 to match the example above example.  \nOther limits can be specified as desired.\n#  Example program to compute the sum of squares.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nn:\n.word\n10\nsumOfSquares:\n.word\n0\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Compute sum of squares from 1 to n.\nlw\n$t0, n\n# \nli\n$t1, 1\n# loop index (1 to n)\nli\n$t2, 0\n# sum \nPage 41",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 48,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nsumLoop:\nmul\n$t3, $t1, $t1\n# index^2\nadd\n$t2, $t2, $t3\nadd\n$t1, $t1, 1\nble\n$t1, $t0, sumLoop\nsw\n$t2, sumOfSquares\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# call code for terminate\nsyscall\n# system call\n.end main\nRefer to the system services section for information on displaying the final results to the \nconsole.\n 5.7 Floating-Point Instructions\nThis section presents a summary of the basic, most common floating-point arithmetic \ninstructions.  The MIPS Instruction Set Appendix presents a more comprehensive list \nof the available instructions.\n 5.7.1 Floating-Point Register Usage\nThe floating-point instructions are similar to the integer instructions, however, the \nfloating-point register must be used with the floating-point instructions.  Specifically, \nthis means the architecture does not support the use of integer registers for any floating-\npoint arithmetic operations.\nWhen single-precision (32-bit) floating-point operation is performed, the specified 32-\nbit floating-point register is used.  When a double-precision (64-bit) floating-point \noperation is performed, two 32-bit floating-point registers are used; the specified 32-bit \nfloating-point register and the next numerically sequential register is used by the \ninstruction.  For example, a double-precision operation using $f12 will use \nautomatically $f12 and $f13.\nPage 42",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 49,
      "text": "Chapter  5.0 ► Instruction Set Overview\n 5.7.2 Floating-Point Data Movement\nFloating-point CPU computations are typically performed using floating-point registers. \nAs such, before computations can be performed, data is typically moved into the \nfloating-point registers from other floating-point registers or variables (i.e., memory).  \nWhen a computation is completed the data might be moved out of the floating-point \nregister into a variable or another floating-point register.\nTo support the loading of data from memory into floating-point registers and storing of \ndata in floating-point registers to memory, there are a series of specialized load and store\ninstructions.  The basic format is the same as the integer operations, however the type is \neither \".s\" for single-precision 32-bit IEEE floating-point representation or \".d\" for \ndouble-precision 64-bit IEEE floating-point representation.  More information regarding\nthe representations can be found in Chapter 2, Data Representation.\nThe general forms of the floating-point load and store instructions are as follows:\nInstruction\nDescription\nl.<type>\n FRdest, mem\nLoad value from memory location \nmemory into destination register.\ns.<type>\n FRsrc, mem\nStore contents of source register \ninto memory location.\nmov.<type>  Frdest, FRsrc\nCopy the contents of source register\ninto the destination register.\nIn this case, the floating-point types are \".s\" for single-precision and \".d\" for double-\nprecision.\nAssuming the following data declarations:\nfnum1:\n.float\n3.14\nfnum2:\n.float\n0.0\ndnum1:\n.double\n6.28\ndnum2:\n.double\n0.0\nThe \".float\" directive declares a variable as a 32-bit floating-point value and the \n\".double\" declares a variable as a 64-bit floating-point variable.\nPage 43",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 50,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nTo perform, the basic operations of:\nfnum2 = fnum1\ndnum2 = dnum1\nThe following instructions :\nl.s\n  $f6, fnum1\ns.s\n  $f6, fnum2\n# fnum2 = fnum1\nl.d\n  $f6, dnum1\nmov.d   $f8, $f6\n# unnecessary use of mov\n# just as an example\ns.d\n  $f8, dnum2\n# dnum2 = dnum1\nThe two double-precision operations (l.d and mov.d) reference registers $f6 and $f8 but \nuse registers $f6/$f7 and $f8/$f9 to hold each of the two 64-bit values.\n 5.7.3 Integer / Floating-Point Register Data Movement\nThe arithmetic instructions require either floating-point registers or integer registers and \nwill not allow a combination.  In order to move data between integer and floating-point \nregisters, special instructions are required.  As noted in Chapter 2, MIPS Architecture \nOverview, the floating-point operations are performed in a floating-point co-processor.\nThe general form of the integer and floating-point data movement instructions are as \nfollows:\nInstruction\nDescription\nmfc1\nRdest, FRsrc \nCopy the contents from co-\nprocessor 1 (FPU) float register \nFRsrc into Rdest integer register.\nmfc1.d\nRdest, FRsrc \nCopy the contents from co-\nprocessor 1 (FPU) float registers \nFRsrc and FRsrc+1 into integer \nregisters Rdest and Rdest+1.\nmtc1\nRsrc, FRdest\nCopy the contents from integer Rsrc\nregister to co-processor 1 (FPU) \nfloat register FRdest.\nPage 44",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.77 sec"
    },
    {
      "page_number": 51,
      "text": "Chapter  5.0 ► Instruction Set Overview\nmtc1.d\nRsrc, FRdest\nCopy the contents from integer \nregisters Rdest and Rdest+1 to co-\nprocessor 1 (FPU) float registers \nFRsrc and FRsrc+1.\nNote, the above instructions use a 1 (number one) and not a lower-case letter L.\nFor example, assuming an integer value is in integer register $s0, to copy the value into \nfloating-point register $f12, the following instruction could be used.\nmtc1\n$s0, $f12\nTo copy the contents of $f12, into an integer register $t1, the following instruction could\nbe used.\nmfc1\n$t1, $f12\nThe value copied has not been converted into a different representation.\nIn this example, the integer value in $s0 that was copied into $f12 is still represented as \nan integer in two's complement.  As such, the value in $f12 is not ready for any floating-\npoint arithmetic operations.  The representation of the value must be converted (see next\nsection).\n 5.7.4 Integer / Floating-Point Conversion Instructions\nWhen data is moved between integer and floating-point registers, the data representation\nmust be addressed.  For example, when moving an integer value from an integer register\ninto a floating-point register, the data is still represented as an integer value in two's \ncomplement.  Floating-point operations require an appropriate floating-point \nrepresentation (32-bit or 64-bit).  When data is moved between integer and floating-\npoint registers, a data conversion would typically be required.\nThe general format for the conversion instructions is as follows:\nInstruction\n   Description\ncvt.d.s\nFRdest, FRsrc\nConvert the 32-bit floating-point value \nin register FRsrc into a double \nprecision value and put it in register \nFRdest.\nPage 45",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.78 sec"
    },
    {
      "page_number": 52,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nInstruction\n   Description\ncvt.d.w\nFRdest, FRsrc\nConvert the 32-bit integer in register \nFRsrc into a double precision value and\nput it in register FRdest.\ncvt.s.d\nFRdest, FRsrc\nConvert the 64-bit floating-point value \nin register FRsrc into a 32-bit floating-\npoint value and put it in register \nFRdest.\ncvt.s.w\nFRdest, FRsrc\nConvert the 32-bit integer in register \nFRsrc into a 32-bit floating-point value\nand put it in register FRdest.\ncvt.w.d\nFRdest, FRsrc\nConvert the 64-bit floating-point value \nin register FRsrc into a 32-bit integer \nvalue and put it in register FRdest.\ncvt.w.s\nFRdest, FRsrc\nConvert the 32-bit floating-point value \nin register FRsrc into a 32-bit integer \nvalue and put it in register FRdest.\nAssuming the following data declarations:\niNum:\n.word\n42\nfNum:\n.float\n0.0\nTo convert the integer value in variable iNum and place it as a 32-bit floating-point \nvalue in variable fNum, the following instructions could be used:\nlw\n$t0, iNum\nmtc1\n$t0, $f6\ncvt.s.w\n$f8, $f6\ns.s\n$f8, fNum\nThis code fragment loads the integer value in variable iNum into $t0, and then copies \nthe value into $f6.  The integer value in $f6 is converted into a 32-bit floating-point \nvalue and placed in $f8.  The 32-bit floating-point value is then copied into the fNum \nvariable.  The conversion instruction could have over-written the $f6 register.\nPage 46",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.78 sec"
    },
    {
      "page_number": 53,
      "text": "Chapter  5.0 ► Instruction Set Overview\nAssuming the following data declarations:\npi:\n.double\n3.14\nintPi:\n.word\n0\nTo convert the 64-bit floating-point value in variable pi and place it as a 32-bit integer \nvalue in variable intPi, the following instructions could be used:\nl.d\n$f10, pi\ncvt.w.d\n$f12, $f10\nmfc1\n$t1, $f12\nsw\n$t1, intPi\nThis code fragment initially loads the 64-bit floating-point value into $f10.  The 64-bit \nfloating-point value in $f10 is converted into a 32-bit integer value and placed in $f12.  \nThe integer value in $f12 is copied into $t1 and then copied into the variable intPi.  \nSince conversion from floating-point truncates, the final value in intPi is 3.\n 5.7.5 Floating-Point Arithmetic Operations\nThe arithmetic operations include addition, subtraction, multiplication, division, \nremainder (remainder after division), logical AND, and logical OR.\nThe general format for these basic instructions is as follows:\nInstruction\n   Description\nadd.<type> FRdest, FRsrc, FRsrc\n   FRdest = FRsrc + FRsrc\nsub.<type> FRdest, FRsrc, FRsrc\n   FRdest = FRsrc - FRsrc\nmul.<type> FRdest, FRsrc, FRsrc\n   FRdest = FRsrc * FRsrc\ndiv.<type> FRdest, FRsrc, FRsrc\n   FRdest = FRsrc / FRsrc\nrem.<type> FRdest, FRsrc, FRsrc\n   FRdest = FRsrc % FRsrc\nAssuming the following data declarations:\nfnum1:\n.float\n6.28318\nfnum2:\n.float\n3.14159\nfans1:\n.float\n0.0\nfans2:\n.float\n0.0\nPage 47",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.78 sec"
    },
    {
      "page_number": 54,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\ndnum1:\n.double\n42.3\ndnum2:\n.double\n73.6\ndans1:\n.double\n0.0\ndans2:\n.double\n0.0\nTo perform, the basic operations of:\nfans1 = fnum1 + fnum2\nfans2 = fnum1 * fnum2\ndans1 = dnum1 - dnum2\ndans2 = dnum1 / dnum2\nThe following instructions:\nl.s\n$f4, fnum1\nl.s\n$f6, fnum2\nadd.s\n$f8, $f4, $f6\ns.s\n$f8, fans1\n# fans1 = fnum1 + fnum2\nmul.s\n$f10, $f4, $f6\ns.s\n$f10, fans2\n# fans2 = fnum1 * fnum2\nl.d\n$f4, dnum1\nl.d\n$f6, dnum2\nsub.d\n$f8, $f4, $f6\ns.d\n$f8, dans1\n# dans1 = dnum1 - dnum2\ndiv.d\n$f10, $f4, $f6\ns.d\n$f10, dans2\n# dans2 = dnum1 / dnum2\nFor the double-precision instructions, the specified register and the next numerically \nsequential register is used.  For example, the l.d instruction sets the $f4 and $f5 32-bit \nregisters with the 64-bit value.\n 5.7.6 Example Programs\nThis section provides some example using the floating-point instructions to perform \nsome basic calculations.\nPage 48",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "18.78 sec"
    },
    {
      "page_number": 55,
      "text": "Chapter  5.0 ► Instruction Set Overview\n 5.7.6.1 Example Program, Floating-Point Arithmetic\nThe following is an example program to compute the surface area\nand volume of a sphere. \nThe formulas for the surface area and volume of a sphere are as\nfollows:\nsurfaceArea = 4.0 ∗pi ∗radius\n2\nvolume = 4.0∗pi\n3.0\n∗radius\n3\nThis example main initializes the radius to an arbitrary floating-point value.\n#  Example program to calculate the surface area\n#  and volume of a sphere given the radius.\n# -----------------------------------------------------\n#  Data Declarations\n.data\npi:\n.float\n3.14159\nfourPtZero:\n.float\n4.0\nthreePtZero:\n.float\n3.0\nradius:\n.float\n17.25\nsurfaceArea:\n.float\n0.0\nvolume:\n.float\n0.0\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n#  Compute: (4.0*pi) which is used for both equations.\nl.s\n$f2, fourPtZero\nl.s\n$f4, pi\nmul.s\n$f4, $f2, $f4\n# 4.0 * pi\nPage 49",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page55_img1.jpeg"
      ],
      "img_summary_files": [],
      "img_vision_files": [
        "output\\images\\img_vision\\MIPS_Assembly_Language_small_163_page55_img1_vision.json"
      ],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 56,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\nl.s\n$f6, radius\n# radius\n# -----\n#  Calculate surface area of a sphere.\n#\nsurfaceArea = 4.0 * pi * radius^2\nmul.s\n$f8, $f6, $f6\n# radius^2\nmul.s\n$f8, $f4, $f8\n# 4.0*pi * radius^2\ns.s\n$f8, surfaceArea\n# store final answer\n# -----\n#  Calculate volume of a sphere.\n#\nvolume = (4.0 * pi / 3.0) * radius^3\nl.s\n$f8, threePtZero\ndiv.s\n$f2, $f4, $f8\n# (4.0 * pi / 3.0)\nmul.s\n$f10, $f2, $f2\nmul.s\n$f10, $f10, $f6\n# radius^3\nmul.s\n$f12, $f6, $f10\n# * 4.0*pi/3.0\ns.s\n$f12, volume\n# store final answer\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nRefer to the system services section for information on displaying the final results to the \nconsole.\n 5.7.6.2 Example Program, Integer / Floating-Point Conversion\nThe following is an example program to sum an array of integer values and compute the \naverage as a floating-point value.  This requires conversion of 32-bit integer values into \n32-bit floating-point values.\nPage 50",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 57,
      "text": "Chapter  5.0 ► Instruction Set Overview\n#  Example program to sum an array of integers\n#  and compute the float average.\n# -----------------------------------------------------\n#  Data Declarations\n.data\niArray:\n.word\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12\nlength:\n.word\n12\niSum:\n.word\n0\nfAve:\n.float\n0.0\n# -----------------------------------------------------\n#  Text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Find the sum of the integer numbers.\nla\n$t0, iArray\n# array starting addr\nlw\n$t1, length\n# array length\nli\n$t2, 0\n# set sum=0\nsumLoop:\nlw\n$t3, ($t0)\n# get iArray(n)\nadd\n$t2, $t2, $t3\n# sum=sum+iArray(n)\n \naddu\n$t0, $t0, 4\n# update iArray addr\nsub\n$t1, $t1, 1\nbnez\n$t1, sumLoop\nsw\n$t2, iSum\n# save integer sum\nmtc1\n$t2, $f6\n# move to flt reg\ncvt.s.w\n$f6, $f6\n# cvt to flt format\nlw\n$t1, length\nmtc1\n$t1, $f8\n# move to float reg\ncvt.s.w\n$f8, $f8\n# cvt to float format\nPage 51",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 58,
      "text": "Chapter 5.0 ◄ Instruction Set Overview\ndiv.s\n$f10, $f6, $f8\n# sum / length\ns.s\n$f10, fAve\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nPage 52",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 59,
      "text": "6.0\nAddressing Modes\nThis chapter provides basic information regarding addressing modes and the associated \naddress manipulations on the MIPS architecture.  The addressing modes are the \nsupported methods for specifying the value or address of a data item being accessed \n(read or written).  This might include an actual value, the name of a variable, or the \nlocation in an array.\nSince the MIPS architecture, as simulated in the QtSpim simulator, is a 32-bit \narchitecture, all addresses are words (32-bits).\n 6.1 Direct Mode\nDirect addressing mode is when the register or memory location contains the actual \nvalues.\nFor example:\nlw\n$t0, var1\nlw\n$t1, var2\nRegisters and variables $t0, $t1, var1, and var2 are all accessed in direct mode \naddressing.\n 6.2 Immediate Mode\nImmediate addressing mode is when the actual value is one of the operands.\nFor example:\nli\n$t0, 57\nadd\n$t0, $t0, 57\nThe value 57 is immediate mode addressing.  The register $t0 is direct mode addressing.\nPage 53",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 60,
      "text": "Chapter 6.0 ◄ Addressing Modes\n 6.3 Indirection\nThe pair of parenthesis, ( )'s, are used to denote an indirect memory access.  An indirect \nmemory access means the CPU will read the provided address and then go to that \naddress to access the value located there.  This involves more work for the CPU than the\npreviously presented addressing modes (direct and immediate).  This is typically how \nelements are accessed in a list or array.  For example, to get a value from a list of longs:\nla\n$t0, lst\nlw\n$s1, ($t0)\nThe address, in $t0, is a word size (32-bits).  Memory is byte addressable.  As such, if \nthe data items in \"lst\" (from above) are words, then four must be added to get the next \nelement.\nFor example, the instructions:\nadd\n$t0, $t0, 4\nlw\n$s2, ($t0)\nwill get the next word value in array (named lst in this example).\nA form of displacement addressing is allowed.  For example, to get the second item \nfrom a list of word sized values:\nla\n$t0, lst\nlw\n$s1, 4($t0)\nThe \"4\" is added to the address before the memory access.  However, the register is not \nchanged.  Thus, the location or address being accessed is displaced or temporarily \nchanged as needed.\n 6.3.1 Bounds Checking\nIn a high-level language, the compiler is capable of ensuring that the index for an \nelement in an array is legal and within the boundary of the array being accessed. Thus, \nthe compiler can issue an error message and help identify when and where a program is \ntrying to access beyond the end of an array (e.g., accessing the 110th element of a 100 \nelement array).\nThis type of bounds checking is not available at the assembly-language level.\nPage 54",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 61,
      "text": "Chapter  6.0 ► Addressing Modes\nIf the assembly-language program attempts to access the 110th element of an array, the \nvalue at that memory location will be returned with no error.  Of course, the value \nreturned is not likely to be useful.\nIf the memory access attempting to be accessed is outside the general scope of the \nprogram, an exception will be generated.  An exception is a run-time error, and the \nQtSpim simulator will provide the line where the exception occurred.  For example, \nattempting to access a memory location in the reserved section would not be allowed \nand thus generate an exception.  This could easily occur if the programmer uses a \nregister with a data item instead of a correct address.\nAdditionally, no error is generated when a program attempts to access a word (32-bits) \nin an array of halfwords (16-bits).  In this case two halfwords will be read into the \nregisters and treated as a single value.  Of course, the value will not be correct or useful.\n 6.4 Examples\nThis section provides some example using the addressing modes to access arrays and \nperform basic calculations.\n 6.4.1 Example Program, Sum and Average\nThe following example computes the sum and average for an array integer values.  The \nvalues are calculated and saved into memory variables.\n#  Example to compute the sum and integer average\n#  for an array of integer values.\n# -----------------------------------------------------\n#  Data Declarations\n.data\narray:\n.word    1,  3,  5,  7,  9, 11, 13, 15, 17, 19\n.word   21, 23, 25, 27, 29, 31, 33, 35, 37, 39\n.word   41, 43, 45, 47, 49, 51, 53, 55, 57, 59\nlength:\n.word   30\nsum:\n.word    0\naverage:\n.word    0\nPage 55",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 62,
      "text": "Chapter 6.0 ◄ Addressing Modes\n# -----------------------------------------------------\n#  Basic approach:\n#\n- loop through the array\n#\naccess each value, update sum\n#\n- calculate the average\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Loop through the array to calculate sum\nla\n$t0, array\n# array starting address\nli\n$t1, 0\n# loop index, i=0\nlw\n$t2, length\n# length\nli\n$t3, 0\n# initialize sum=0\nsumLoop:\nlw\n$t4, ($t0)\n# get array[i]\nadd\n$t3, $t3, $t4\n# sum = sum + array[i]\nadd\n$t1, $t1, 1\n# i = i+1\nadd\n$t0, $t0, 4\n# update array address\nblt\n$t1, $t2, sumLoop\n# if i<length, continue\nsw\n$t3, sum\n# save sum\n# -----\n#  Calculate average\n#\nnote, sum and length set in section above.\ndiv\n$t5, $t3, $t2\n# ave = sum / length\nsw\n$t5, average\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nPage 56",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.62 sec"
    },
    {
      "page_number": 63,
      "text": "Chapter  6.0 ► Addressing Modes\nThis example program does not display the results to the screen.  For information \nregarding displaying values and strings to output (console), refer to the QtSpim System \nServices section.\n 6.4.2 Example Program, Median\nThe following example finds the median for a sorted array of values.  In this example, \nthe length is given as always even.  As such, the integer median is the integer average \nfor the two middle values.  Specifically, the formula for median is:\nmedianEvenOnly =\n( array[ length/ 2] + array[ length/ 2−1])\n2\nThe 'length/2' notation refers to using division by two to generate the correct index of \nthe appropriate value from the array.  In assembly, we must convert the index into the \noffset from the base address (i.e., starting address) of the array.  Since the array elements\nin this example are words (i.e., 4 bytes), it will be necessary to multiply by four to \nconvert the index into an offset.  That offset is from the start of the array, so the final \naddress is the array base address plus the offset.\nThis requires a series of calculations as demonstrated in the  following example.\n#  Example to find the median of a sorted\n#  array of integer values of even length.\n# -----------------------------------------------------\n#  Data Declarations\n.data\narray:\n.word    1,  3,  5,  7,  9, 11, 13, 15, 17, 19\n.word   21, 23, 25, 27, 29, 31, 33, 35, 37, 39\n.word   41, 43, 45, 47, 49, 51, 53, 55, 57, 59\nlength:\n.word   30\nmedian:\n.word    0\n# -----------------------------------------------------\n#  text/code section\n#  The median for an even length array is defined as:\n#\nmedian = ( array[len/2] + array[len/2-1] ) / 2\n#  Note, the len/2 is the index. Must convert the index\n#  into the an offset from the base address (of the\n#  array.  Since the data is words (4 bytes), multiply\nPage 57",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 64,
      "text": "Chapter 6.0 ◄ Addressing Modes\n#  the index by four to convert to the offset.\n.text\n.globl\nmain\n.ent\nmain\nmain:\nla\n$t0, array\n# starting addr of array\nlw\n$t1, length\n# value of length\ndiv\n$t2, $t1, 2\n# length / 2\nmul\n$t3, $t2, 4\n# cvt index into offset\nadd\n$t4, $t0, $t3\n# add base addr of array\nlw\n$t5, ($t4)\n# get array[len/2]\nsub\n$t4, $t4, 4\n# addr of prev value\nlw\n$t6, ($t4)\n# get array[len/2-1]\nadd\n$t7, $t6, $t5\n# a[len/2] + a[len/2-1]\ndiv\n$t8, $t7, 2\n#  / 2\nsw\n$t8, median\n# save median\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nThis example program does not display the results to the screen.  For information \nregarding displaying values and strings to output (console), refer to the QtSpim System \nServices section.\nFinding the median for an odd length list is left to the reader as an exercise.\nPage 58",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 65,
      "text": "7.0\nStack\nIn a computer, a stack is a type of data structure where items are added and then \nremoved from the stack in reverse order.  That is, the most recently added item is the \nvery first one that is removed.  This is often referred to as Last-In, First-Out (LIFO).\nA stack is heavily used in programming for the storage of information during procedure \nor function calls.  The following chapter provides information and examples regarding  \nprocedure and function calls.\nAdding an item to a stack is referred to as a push or push operation.  Removing an item \nfrom a stack is referred to as a pop or pop operation.\nIt is generally expected that the reader will be familiar with the general concept of a \nstack.\n 7.1 Stack Example\nTo demonstrate the usage of the stack, given an array,  a = {7, 19, 37}, consider \nthe operations:\npush\na[0]\npush\na[1]\npush\na[2]\nFollowed by the operations:\npop\na[0]\npop\na[1]\npop\na[2]\nThe initial push will push the 7, followed by the 19, and finally the 37.  Since the stack \nis last-in, first-out, the first item popped off the stack will be the last item pushed, or 37 \nin this example.  The 37 is placed in the first element of the array (over-writing the 7).  \nAs this continues, the order of the array elements is reversed.\nPage 59",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 66,
      "text": "Chapter 7.0 ◄ Stack\nThe following diagram shows the progress and the results.\nstack\nstack\nstack\nstack\nstack\nstack\n37\n19\n19\n19\n7\n7\n7\n7\n7\nempty\npush\na[0]\npush\na[1]\npush\na[2]\npop\na[0]\npop\na[1]\npop\na[2]\na = {7,\n19, 37}\na = {7,\n19, 37}\na = {7,\n19, 37}\na = \n{37, \n19, 37}\na = \n{37, \n19, 37}\na = \n{37, \n19, 7}\nThe following sections provide more detail regarding the implementation and applicable\ninstructions.\n 7.2 Stack Implementation\nThe current top of the stack is pointed to by the $sp register.  The stack grows \ndownward in memory and it is generally expected that all items pushed and/or popped \nshould be of word size (32-bit).\nThere is no push or pop instruction.  Instead, you must perform the push and pop \noperations manually.\nWhile it is possible to push/pop items of various sizes (byte, halfword, etc.) it is not \nrecommended.  For such operations, it is recommended to use the entire word (4-bytes).\n 7.3 Push\nFor example, a push would subtract the $sp by 4 bytes and then copy the operand to that\nlocation (in that order).  The instructions to push $t9 would be implemented as follows:\nsubu\n $sp, $sp, 4\nsw\n $t9, ($sp)\nWhich will place the contents of the $t9 register at the top of the stack.\nPage 60",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 67,
      "text": "Chapter  7.0 ► Stack\n 7.4 Pop\nA pop would copy the top of the stack to the operand and then add 4 bytes (in that \norder).  To pop the stack into $t2, the instructions would be as follows:\nlw\n $t2, ($sp)\naddu\n $sp, $sp, 4\nWhich will copy the contents of the top of the stack into the $t2 register.\n 7.5 Multiple push's/pop's\nThe preferred method of performing multiple pushes or pops is to perform the $sp \nadjustment only once.  For example, to push registers, $s0, $s1, and $s2:\nsubu\n $sp, $sp, 12\nsw\n $s0, ($sp)\nsw\n $s1, 4($sp)\nsw\n $s2, 8($sp)\nAnd, the commands to pop registers, $s0, $s1, and $s2 as follows:\nlw\n $s0, ($sp)\nlw\n $s1, 4($sp)\nlw\n $s2, 8($sp)\naddu\n $sp, $sp, 12\nBy performing the stack adjustment only once, it is more efficient for the architecture to \nexecute.\n 7.6 Example Program, Stack Usage\nThe following example uses a stack to reverse the elements in an array.  The program \nwill push all elements of the array to the stack and then pop all elements back into the \narray.   This will place the elements back into the array in reverse order based on the \nbasic functionality of the stack.\n#  Example to reverse values in an array\n#  by using the stack.\n# -----------------------------------------------------\n#  Data Declarations\nPage 61",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 68,
      "text": "Chapter 7.0 ◄ Stack\n.data\narray:\n.word      1,  3,  5,  7,  9, 11, 13, 15, 17, 19\n.word     21, 23, 25, 27, 29, 31, 33, 35, 37, 39\n.word     41, 43, 45, 47, 49, 51, 53, 55, 57, 59\nlength:\n.word     30\n# -----------------------------------------------------\n#  Text/code section\n#  Basic approach:\n#\n- loop to push each element onto the stack\n#\n- loop to pop each element off the stack\n#  Final result is all elements reversed.\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Loop to read items from array and push to stack.\nla\n$t0, array\n# array starting address\nli\n$t1, 0\n# loop index, i=0\nlw\n$t2, length\n# length\npushLoop:\nlw\n$t4, ($t0)\n# get array[i]\nsubu\n$sp, $sp, 4\n# push array[i]\nsw\n$t4, ($sp)\nadd\n$t1, $t1, 1\n# i = i+1\nadd\n$t0, $t0, 4\n# update array address\nblt\n$t1, $t2, pushLoop\n# if i<length, continue\n# -----\n#  Loop to pop items from stack and write into array.\nla\n$t0, array\n# array starting address\nli\n$t1, 0\n# loop index, i=0\nPage 62",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 69,
      "text": "Chapter  7.0 ► Stack\nlw\n$t2, length\n# length (redundant line)\npopLoop:\nlw\n$t4, ($sp)\naddu\n$sp, $sp, 4\n# pop array[i]\nsw\n$t4, ($t0)\n# set array[i]\nadd\n$t1, $t1, 1\n# i = i+1\nadd\n$t0, $t0, 4\n# update array address\nblt\n$t1, $t2, popLoop\n# if i<length, continue\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nIt must be noted that there are easier ways to reverse a set of numbers, but they would \nnot help demonstrate stack operations.\nPage 63",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 70,
      "text": "Chapter 7.0 ◄ Stack\nPage 64",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 71,
      "text": "8.0\nProcedures/Functions\nThis chapter provides an overview of using assembly language procedures/functions.  In\nC/C++ a procedure is referred to as a void function.  Other languages refer to such \nfunctions as procedures.  A function returns a single value in a more mathematical \nsense.  C/C++ refers to functions as value returning functions.\nWith regard to calling a procedure/function, there are two primary activities; linkage and\nargument transmission.  Each is explained in the following sections.  Additionally, using\nprocedures/functions in MIPS assembly language requires the use of a series of special \npurpose registers.  These special purpose registers are part of the basic integer register \nset but have a dedicated purpose based upon standardized and conventional usage.\n 8.1 MIPS Calling Conventions\nWhen writing MIPS assembly-language procedures, the MIPS standard calling \nconventions should be utilized.  This ensures that the code can be more effectively re-\nused, can interact with other compiler-generated code or mixed-language programs, and \nutilize high-level language libraries.\nThe calling conventions address register usage, argument passing and register \npreservation.\nThere are two categories of procedures as follows:\n•\nNon-leaf procedures\n◦These procedures call other procedures.\n•\nLeaf procedures\n◦These procedures do not call other procedures (or themselves).\nThe standard calling convention specifies actions for the caller (routine that is calling) \nand the callee (routine that is being called).  The specific requirements for each are \ndetailed in the following sections.\nPage 65",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 72,
      "text": "Chapter 8.0 ◄ Procedures/Functions\n 8.2 Procedure/Function Format\nThe basic format for a procedure/function declaration uses a global declaration directive \n(\".globl <procName>\"), an entry point directive (\".ent <procName>\"), and an entry label\nfor the procedure.  Generally, a procedure declaration is terminated with an end \ndirective (\".end <procName>\").  The general syntax is as follows:\n.globl  functionName\n.ent    functionName\nfunctionName:\n# code goes here\n.end  functionName\nThe use of the \".end <functionName>\" directive is optional in the QtSpim simulator.\n 8.3 Caller Conventions\nThe calling convention addresses specific requirements for the caller or routine that is \ncalling a procedure.\n•\nThe calling procedures are expected to save any non-preserved registers ($a0 - \n$a3, $t0 - $t9, $v0, $v1, $f0 - $f10 and $f16 - $f18) that are required after the \ncall is completed.\n•\nThe calling procedure should pass all arguments.\n◦The first argument is passed in either $a0 or $f12 ($a0 if integer or $f12 if \nfloat single or double precision).\n◦The second argument is passed in either $a1 or $f14 ($a1 if integer or $f14 if\nfloat single or double precision).\n◦The third argument is passed in $a2 (integer only).\n◦If the third argument is float, it must be passed on the stack.\n◦The fourth argument is passed in $a3 (integer only).\n◦If the fourth argument is float, it must be passed on the stack.\nRemaining arguments are passed on the stack.  Arguments on the stack should be placed\non the stack in reverse order.  Call-by-reference arguments load address (la instruction) \nand call-by-value load the value.\nCalling procedure should use the \"jal <proc>\" instruction.\nPage 66",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 73,
      "text": "Chapter  8.0 ► Procedures/Functions\nUpon completion of the procedure, the caller procedure must restore any saved non-\npreserved registers and adjust the stack point ($sp) as necessary if any arguments were \npassed on the stack.\nNote, for floating-point arguments appearing in registers you must allocate a pair of \nregisters (even if it's a single precision argument) that start with an even register.\n 8.4 Linkage\nThe term linkage refers to the basic process of getting to a procedure and getting back to\nthe correct location in the calling routine.  This does not include argument transmission, \nwhich is addressed in the next section.\nThe basic linkage operation use the jal and jr instructions.  Both instructions utilize the \n$ra register.  This register is set to the return address as part of the procedure call.\nThe call to a procedure/function requires the procedure/function name, generically \nlabeled as <procName>, as follows:\njal    <procName>\nThe jal, or jump and link, instruction, will copy the $pc into the $ra register and jump \nto the procedure <procName>.  Recall that the $pc register points to the next instruction \nto be executed.  That will be the instruction immediately after the call, which is the \ncorrect place to return to when the procedure/function has completed.\nIf the procedure/function does not call any other procedures/functions, nothing \nadditional is required with regard to the $ra register.\nA procedure that does not call another procedure is referred to as a \"leaf procedure\".  A \nprocedure that calls another procedure is referred to as a \"non-leaf procedure\".\nThe return from procedure is as follows:\n jr     $ra\nIf the procedure/function calls yet another procedure/function, the $ra must be \npreserved.  Since $ra contains the return address, it will be changed when the procedure/\nfunction calls the next procedure/function.  As such, it must be saved and restored from \nthe stack in the calling procedure.  This is typically performed only once at the \nbeginning and then at the end of the procedure (for non-leaf procedures).\nRefer to the example programs for a more detailed series of examples that demonstrate \nthe linkage.\nPage 67",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.63 sec"
    },
    {
      "page_number": 74,
      "text": "Chapter 8.0 ◄ Procedures/Functions\n 8.5 Argument Transmission\nBased on the context, parameters may be transmitted to procedures/functions as either \nvalues or addresses.  These basic approaches are implemented in high-level languages.\nThe basic argument transmission is accomplished via a combination of registers and the \nstack.\n 8.5.1 Call-by-Value\nCall-by-value involves passing a copy of the information being passed to the procedure \nor function.  As such, the original value can not be altered.\n 8.5.2 Call-by-Reference\nCall-by-reference involves passing the address of the variables.  Call-by-reference is \nused when passing arrays or when passing variables that will be altered or set by the \nprocedure or function.\n 8.5.3 Argument Transmission Conventions\nThe basic argument transmission is accomplished via a combination of registers and the \nstack.\nInteger arguments can be passed in registers $a0, $a1, $a2, and $a3 and floating-point \nvalues passed in $f12 and $f14 (single or double precision floating-point).\n•\nThe first argument is passed in either $a0 or $f12 ($a0 if integer or $f12 if float \nsingle or double precision).\n•\nThe second argument is passed in either $a1 or $f14 ($a1 if integer or $f14 if \nfloat single or double precision).\n•\nThe third argument is passed in $a2 (integer only).\n•\nIf the third argument is float, it must be passed on the stack.\n•\nThe fourth argument is passed in $a3 (integer only).\n•\nIf the fourth argument is float, it must be passed on the stack.\nIf the first argument is integer, $a0 is used and $f12 should not be used at all.  If the first\nargument is floating-point value, $f12 is used and $a0 is not used at all.  Any additional \narguments are passed on the stack.\nPage 68",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 75,
      "text": "Chapter  8.0 ► Procedures/Functions\nThe following table shows the argument order and register allocation.\n1st\n2nd\n3rd\n4th\n5th\nNth\ninteger\n$a0\n$a1\n$a2\n$a3\nstack\nstack\nor\nor\nor\nor\nfloating-\npoint value\n$f12\n$f14\nstack\nstack\nstack\nstack\nRecall that addresses are integers, even when pointing to floating-point values.  As such,\naddresses are passed in integer registers.\n 8.6 Function Results\nA function is expected to return a result (i.e., value returning function).\nInteger registers $v0 or $v1/$v0 are used to return an integer value from a \nfunction/procedure call.  Floating-point registers $f0 and $f1 are used to return a \nfloating-point value from a function/procedure.\n 8.7 Registers Preservation Conventions\nThe MIPS calling convention requires that only specific registers (not all) be saved \nacross procedure calls.\n•\nInteger registers $s0 - $s7 must be saved by the procedure.\n•\nFloating-point registers $f20 - $f30 must be saved by the procedure.\nWhen writing a procedure, this will require that the registers $s0 - $s7 or $f20 - $f30 \n(single or double precision) be pushed and popped from the stack if those registers are \nutilized/changed.  When calling a procedure, the main routine must be written so that \nany values required across procedure calls be placed in register $s0 - $s7 or $f20 - $f30 \n(single or double precision).\nInteger registers $t0 - $t9 and floating-point registers $f4 - $f10 and $f16 - $f18 (single \nor double precision) are used to hold temporary quantities that do not need to be \npreserved across procedure calls.\nPage 69",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 76,
      "text": "Chapter 8.0 ◄ Procedures/Functions\n 8.8 Miscellaneous Register Usage\nRegisters $at, $k0, and $k1 are reserved for the assembler and operating system and \nshould not be used by programs.  Register $fp is used to point to the procedure call \nframe on the stack.  This can be used when arguments are passed on the stack.\nRegister $gp is used as a global point (to point to globally accessible data areas).  This \nregister is not typically used when writing assembly programs directly.\n 8.9 Summary, Callee Conventions\nThe calling convention addresses specific requirements for the callee or routine that is \nbeing called from another procedure (which includes the main routine).\n•\nPush any altered \"saved\" registers on the stack.\n◦Specifically, this includes $s0 - $s7, $f20 - $f30, $ra, $fp, or $gp.\n◦If the procedure is a non-leaf procedure, $ra must be saved.\n◦If $fp is altered, $fp must be saved which is required when arguments are \npassed on the stack\n◦Space for local variables should be created on the stack for stack dynamic \nlocal variables.\n•\nNote, when altering the $sp register, it should be done in a single operation \n(instead of a series).\n•\nIf arguments are passed on the stack, $fp should be set as follows:\n◦$fp = $sp + (frame size)\n◦This will set $fp pointing to the first argument passed on the stack.\nThe procedure can access first 4 integer arguments in registers $a0 - $a3 and the first \ntwo float registers $f12 - $f14.\nArguments passed on the stack can be accessed using $fp.  The procedure should place \nreturned values (if any) into $v0 and $v1.\n•\nRestore saved registers\n◦Includes $s0 - $s7, $fp, $ra, $gp if they were pushed.\n◦Return to the calling procedure via the  jr $ra  instruction.\nThe procedures example section provides a series of example procedures and functions \nincluding register usage and argument transmission.\nPage 70",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 77,
      "text": "Chapter  8.0 ► Procedures/Functions\n 8.10 \nCall Frame\nThe procedure/function call frame or activation record is what the information placed on\nthe stack is called.  As noted in the previous sections, the procedure call frame includes \npassed parameters (if any) and the preserved registers.  In addition, space for the \nprocedures’ local variables (if any) is allocated on the stack.\nA general overview of the call frame is shown as follows:\nCall\nFrame\nArguments\nPreserved \nRegisters\nLocal \nVariables\nEach part of the call frame may be a different size based on how many arguments are \npassed (if any), which registers must be preserved (if any), or the amount and size of the\nlocal variables (if any).\n 8.10.1.1 \nStack Dynamic Local Variables\nThe local variables, also referred to as stack dynamic local variables, are typically \nallocated by the compiler and assigned to stack locations.  This allows a more efficient \nuse of memory for high-level languages.  This can be very important in large programs.\nFor example, assume there are 10 procedures each with a locally declared 100,000 \nelement array of integers.  Since each integer typically requires 4-bytes, this would \nmean 400,000 bytes for each procedure with a combined total of 4,000,000 bytes (or \nabout ~4MB) for all ten procedures.\nFor the standard method of stack dynamic local variables, each array is only allocated \nwhen the procedure is active (i.e., being executed).  If none of the procedures/functions \nare called, no memory is allocated.  If only two of the arrays are active at any given \ntime, only 800,000 bytes are allocated at any given time.\nPage 71",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 78,
      "text": "Chapter 8.0 ◄ Procedures/Functions\nHowever, if the arrays were to be declared statically (i.e., not the standard local \ndeclaration in the previous examples), the ~4MB of memory is allocated even if none of \nthe procedures are ever called.  This can lead to excessive memory usage which can \nslow a program down.\n 8.11 \nProcedure Examples\nThis section presents a series of example procedures of varying complexity.\n 8.11.1 \nExample Program, Power Function\nThis section presents a very simple example of a function call.  The example includes a \nsimple main procedure and a simple function that computes xy (i.e., x to the y power).  \nThe high-level language call, shown in C/C++ here, would be:\nanswer = power(x, y);\nWhere x and y are passed by value and the result is returned to the variable answer.  The\nmain passes the arguments by value and receives the result in $v0 (as per the \nconvention).  The main then saves the result into the variable answer.\n#  Example function to demonstrate calling conventions\n#  Function computes power (i.e., x to y power).\n# -----------------------------------------------------\n#  Data Declarations\n.data\nx:\n.word\n3\ny:\n.word\n5\nanswer:\n.word\n0\n# ------------------------------------\n#  Main routine.\n#  Call simple procedure to add two numbers.\n.text\n.globl\nmain\n.ent\nmain\nmain:\nPage 72",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 79,
      "text": "Chapter  8.0 ► Procedures/Functions\nlw\n$a0, x\n# pass arg's to function\nlw\n$a1, y\njal\npower\nsw\n$v0, answer\nli\n$v0, 10\nsyscall\n# terminate\n.end\nmain\n# ------------------------------------\n# Function to find and return x^y\n# -----\n#  Arguments\n#\n$a0 – x\n#\n$a1 – y\n#  Returns\n#\n$v0 - x^y\n.globl\npower\n.ent\npower\npower:\nli\n$v0, 1\nli\n$t0, 0\npowLoop:\nmul\n$v0, $v0, $a0\nadd\n$t0, $t0, 1\nblt\n$t0, $a1, powLoop\njr\n$ra\n.end\npower\nRefer to the next section for a more complex example.\n 8.11.2 \nExample program, Summation Function\nThe following is an example program to demonstrate a procedure call.\n#  Example function to demonstrate calling conventions.\n#  Simple function to sum six arguments.\n# ------------------------------------\nPage 73",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 80,
      "text": "Chapter 8.0 ◄ Procedures/Functions\n#  Data Declarations\n.data\nnum1:\n.word\n3\nnum2:\n.word\n5\nnum3:\n.word\n3\nnum4:\n.word\n5\nnum5:\n.word\n3\nnum6:\n.word\n5\nsum:\n.word\n0\n# ------------------------------------\n#  Main routine.\n#  Call function to add six numbers.\n#\nFirst 4 arguments are passed in $a0-$a3.\n#\nNext 2 arguments are passed on the stack.\n.text\n.globl\nmain\n.ent\nmain\nmain:\nlw\n$a0, num1\n# pass arg's\nlw\n$a1, num2\nlw\n$a2, num3\nlw\n$a3, num4\nlw\n$t0, num5\nlw\n$t1, num6\nsubu\n$sp, $sp, 8\nsw\n$t0, ($sp)\nsw\n$t1, 4($sp)\njal\naddem\nsw\n$v0, sum\naddu\n$sp, $sp, 8\n# clear stack\nli\n$v0,10\nsyscall\n# terminate\n.end\nmain\n# ------------------------------------\n#  Example function to add 6 numbers\nPage 74",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 81,
      "text": "Chapter  8.0 ► Procedures/Functions\n# -----\n#  Arguments\n#\n$a0 - num1\n#\n$a1 - num2\n#\n$a2 - num3\n#\n$a3 - num4\n#\n($fp) - num5\n#\n4($fp) - num6\n#  Returns\n#\n$v0 – num1+num2+num3+num4+num5+num6\n.globl\naddem\n.ent\naddem\naddem:\nsubu\n$sp, $sp, 4\n# preserve registers\nsw\n$fp, ($sp)\naddu\n$fp, $sp, 4\n# set frame pointer\n# -----\n#  Perform additions.\nli\n$v0, 0\nadd\n$v0, $v0, $a0\n# num1\nadd\n$v0, $v0, $a1\n# num2\nadd\n$v0, $v0, $a2\n# num3\nadd\n$v0, $v0, $a3\n# num4\nlw\n$t0, ($fp)\n# num5\nadd\n$v0, $v0, $t0\nlw\n$t0, 4($fp)\n# num6\nadd\n$v0, $v0, $t0\n# -----\n#  Restore registers.\nlw\n$fp, ($sp)\naddu\n$sp, $sp, 4\njr $ra\n.end\naddem\nRefer to the next section for a more complex example.\nPage 75",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 82,
      "text": "Chapter 8.0 ◄ Procedures/Functions\n 8.11.3 \nExample Program, Pythagorean Theorem Procedure\nThe following is an example of a procedure that calls another function.\nGiven the a and b sides of a right triangle, the c side can be computed\nas follows:\ncSide = √aSide\n2 + bSide\n2\nThis example program will call a procedure to compute the c sides of a\nseries of right triangles.  The a sides and b sides are stored in an arrays,\naSides[] and bSides[] and results stored into an array, cSides[].  The procedure will also \ncompute the minimum, maximum, sum, and average of the cSides[] values.  All values \nare integers.  In order to compute the integer square root, a iSqrt() function is used.  The \niSqrt() function uses a simplified version of  Newton’s method.\n#  Example program to calculate the cSide for each\n#  right triangle in a series of right triangles\n#  given the aSides and bSides using the\n#  Pythagorean theorem.\n#  Pythagorean theorem:\n#\ncSide = sqrt ( aSide^2 + bSide^2 )\n#  Provides examples of MIPS procedure calling.\n# -----------------------------------------------------\n#  Data Declarations\n.data\naSides:\n.word   19, 17, 15, 13, 11, 19, 17, 15, 13, 11\n.word   12, 14, 16, 18, 10\nbSides:\n.word   34, 32, 31, 35, 34, 33, 32, 37, 38, 39\n.word   32, 30, 36, 38, 30\ncSides:\n.space  60\nlength:\n.word    15\nmin:\n.word     0\nmax:\n.word     0\nsum:\n.word     0\nave:\n.word     0\nPage 76\na\nb",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 83,
      "text": "Chapter  8.0 ► Procedures/Functions\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Main program calls the cSidesStats routine.\n#  The HLL call is as follows:\n#\ncSidesStats(aSides, bSides, cSides, length, min,\n#\nmax, sum, ave)\n#  Note:\n#\nThe arrays are passed by reference\n#\nThe length is passed by value\n#\nThe min, max, sum, and ave are pass by reference.\nla\n$a0, aSides\n# address of array\nla\n$a1, bSides\n# address of array\nla\n$a2, cSides\n# address of array\nlw\n$a3, length\n# value of length\nla\n$t0, min\n# address for min\nla\n$t1, max\n# address for max\nla\n$t2, sum\n# address for sum\nla\n$t3, ave\n# address for ave\nsubu\n$sp, $sp, 16\nsw\n$t0, ($sp)\n# push addresses\nsw\n$t1, 4($sp)\nsw\n$t2, 8($sp)\nsw\n$t3, 12($sp)\njal\ncSidesStats\n# call routine\naddu\n$sp, $sp, 16\n# clear arguments\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nPage 77",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 84,
      "text": "Chapter 8.0 ◄ Procedures/Functions\n# -----------------------------------------------------\n#  Function to calculate the cSides[] for each right\n#  triangle in a series of right triangles given the \n#  aSides[] and bSides[] using the Pythagorean theorem.\n#  Pythagorean theorem formula:\n#\ncSides[n] = sqrt ( aSides[n]^2 + bSides[n]^2 )\n#  Also finds and returns the minimum, maximum, sum,\n#  and average for the cSides.\n#  Uses the iSqrt() routine to find the integer\n#  square root of an integer.\n# -----\n#  Arguments:\n#\n$a0 - address of aSides[]\n#\n$a1 - address of bSides[]\n#\n$a2 - address of cSides[]\n#\n$a3 - list length\n#\n($fp) - addr of min\n#\n4($fp) - addr of max\n#\n8($fp) - addr of sum\n#\n12($fp) - addr of ave\n#  Returns (via passed addresses):\n#\ncSides[]\n#\nmin\n#\nmax\n#\nsum\n#\nave\n.globl\ncSidesStats\n.ent\ncSidesStats\ncSidesStats:\nsubu\n$sp, $sp, 24\n# preserve registers\nsw\n$s0, 0($sp)\nsw\n$s1, 4($sp)\nsw\n$s2, 8($sp)\nsw\n$s3, 12($sp)\nsw\n$fp, 16($sp)\nsw\n$ra, 20($sp)\naddu\n$fp, $sp, 24\n# set frame pointer\nPage 78",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.64 sec"
    },
    {
      "page_number": 85,
      "text": "Chapter  8.0 ► Procedures/Functions\n# -----\n#  Loop to calculate cSides[]\n#\nNote, must use $s<n> registers due to iSqrt() call\nmove\n$s0, $a0\n# address of aSides\nmove\n$s1, $a1\n# address of bSides\nmove\n$s2, $a2\n# address of cSides\nli\n$s3, 0\n# index = 0\ncSidesLoop:\nlw\n$t0, ($s0)\n# get aSides[n]\nmul\n$t0, $t0, $t0\n# aSides[n]^2\nlw\n$t1, ($s1)\n# get bSides[n]\nmul\n$t1, $t1, $t1\n# bSides[n]^2\nadd\n$a0, $t0, $t1\njal\niSqrt\n# call iSqrt()\nsw\n$v0, ($s2)\n# save to cSides[n]\naddu\n$s0, $s0, 4\n# update aSides addr\naddu\n$s1, $s1, 4\n# update bSides addr\naddu\n$s2, $s2, 4\n# update cSides addr\naddu\n$s3, $s3, 1\n# index++\nblt\n$s3, $a3, cSidesLoop\n# if indx<len, loop\n# -----\n#  Loop to find minimum, maximum, and sum.\nmove\n$s2, $a2\n# strt addr of cSides\nli\n$t0, 0\n# index = 0\nlw\n$t1, ($s2)\n# min = cSides[0]\nlw\n$t2, ($s2)\n# max = cSides[0]\nli\n$t3, 0\n# sum = 0\nstatsLoop:\nlw\n$t4, ($s2)\n# get cSides[n]\nbge\n$t4, $t1, notNewMin\n# if cSides[n] >=\n#   item -> skip\nmove\n$t1, $t4\n# set new min value\nnotNewMin:\nPage 79",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.65 sec"
    },
    {
      "page_number": 86,
      "text": "Chapter 8.0 ◄ Procedures/Functions\nble\n$t4, $t2, notNewMax\n# if cSides[n] <= \n#   item -> skip\nmove\n$t2, $t4\n# set new max value\nnotNewMax:\nadd\n$t3, $t3, $t4\n# sum += cSides[n]\naddu\n$s2, $s2, 4\n# update cSides addr\naddu\n$t0, $t0, 1\n# index++\nblt\n$t0, $a3, statsLoop\n# if indx<len, loop\nlw\n$t5, ($fp)\n# get address of min\nsw\n$t1, ($t5)\n# save min\nlw\n$t5, 4($fp)\n# get address of max\nsw\n$t2, ($t5)\n# save max\nlw\n$t5, 8($fp)\n# get address of sum\nsw\n$t3, ($t5)\n# save sum\ndiv\n$t0, $t3, $a3\n# ave = sum / len\nlw\n$t5, 12($fp)\n# get address of ave\nsw\n$t0, ($t5)\n# save ave\n# -----\n#  Done, restore registers and return to calling routine.\nlw\n$s0, 0($sp)\nlw\n$s1, 4($sp)\nlw\n$s2, 8($sp)\nlw\n$s3, 12($sp)\nlw\n$fp, 16($sp)\nlw\n$ra, 20($sp)\naddu\n$sp, $sp, 24\njr\n$ra\n.end\ncSidesStats\n# -----------------------------------------------------\n#  Function to compute integer square root for\n#  an integer value.\nPage 80",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.65 sec"
    },
    {
      "page_number": 87,
      "text": "Chapter  8.0 ► Procedures/Functions\n#  Uses a simplified version of Newtons method.\n#\nx = N\n#\niterate 20 times:\n#\nx' = (x + N/x) / 2\n#\nx = x'\n# -----\n#  Arguments\n#\n$a0 - N\n#  Returns\n#\n$v0 - integer square root of N\n.globl\niSqrt \n.ent\niSqrt \niSqrt: \nmove\n$v0, $a0\n# $v0 = x = N \nli\n$t0, 0\n# counter \nsqrLoop: \ndiv\n$t1, $a0, $v0\n# N/x \nadd\n$v0, $t1, $v0\n# x + N/x \ndiv\n$v0, $v0, 2\n# (x + N/x)/2 \nadd\n$t0, $t0, 1 \nblt\n$t0, 20, sqrLoop \njr\n$ra \n.end\niSqrt\nThis example uses a simplified version of Newton's method.  Further improvements are \nleft to the reader as an exercise.\nPage 81",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.65 sec"
    },
    {
      "page_number": 88,
      "text": "9.0\nQtSpim System Service Calls\nThe operating system must provide some basic services for functions that a user \nprogram can not easily perform on its own.  Some key examples include input and \noutput operations.  These functions are typically referred to as system services.  The \nQtSpim simulator provides a series of operating system like services by using a syscall \ninstruction.\nTo request a specific service from the QtSpim simulator, the 'call code' is loaded in the \n$v0 register.  Based on the specific system service being requested, additional \ninformation may be needed which is loaded in the argument registers (as noted in the \nProcedures/Functions section).\n 9.1 Supported QtSpim System Services\nA list of the supported system services is listed in the below table.  A series of examples \nare provided in the following sections.\nService Name\nCall\nCode\nInput\nOutput\nPrint Integer (32-bit)\n1\n$a0 → integer to be printed\nPrint Float (32-bit)\n2\n$f12 → 32-bit floating-point \nvalue to be printed\nPrint Double (64-bit)\n3\n$f12 → 64-bit floating-point \nvalue to be printed\nPrint String\n4\n$a0 → starting address of \nNULL terminated string to be\nprinted\nRead Integer (32-bit)\n5\n$v0 → 32-bit integer \nentered by user\nRead Float (32-bit)\n6\n$f0 → 32-bit floating-\npoint value entered by user",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.65 sec"
    },
    {
      "page_number": 89,
      "text": "Chapter 9.0 ◄ QtSpim System Service Calls\nRead Double (64-\nbit)\n7\n$f0 → 64-bit floating-\npoint value entered by user\nRead String\n8\n$a0 → starting address of \nbuffer (of where to store \ncharacter entered by user)\n$a1 → length of buffer\nAllocate Memory\n9\n$a0 → number of bytes to \nallocate\n$v0 → starting address of \nallocated memory\nTerminate\n10\nPrint Character\n11\n$a0 → character to be printed\nRead Character\n12\n$v0 → character entered \nby user\nFile Open\n13\n$a0 → file name string, \nNULL terminated\n$a1 → access flags\n$a2 → file mode, (UNIX \nstyle)\n$v0 → file descriptor\nFile Read\n14\n$a0 → file descriptor\n$a1 → buffer starting address\n$a2 → number of bytes to \nread\n$v0 → number of bytes \nactually read from file (-1 \n= error, 0 = end of file)\nFile Write\n15\n$a0 → file descriptor\n$a1 → buffer starting address\n$a2 → number of bytes to \nread\n$v0 → number of bytes \nactually written to file (-1 \n= error, 0 = end of file)\nFile Close\n16\n$a0 → file descriptor\nThe file open access flags are defined as follows:\nRead = 0x0, Write = 0x1, Read/Write = 0x2\nOR Create = 0x100, Truncate = 0x200, Append = 0x8\nOR Text = 0x4000, Binary = 0x8000\nFor example, for a file read operation, the 0x0 would be selected.  For a file write \noperation, the 0x1 would be selected.\nPage 84",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.65 sec"
    },
    {
      "page_number": 90,
      "text": "Chapter  9.0 ► QtSpim System Service Calls\n 9.2 QtSpim System Services Examples\nThis section provides a series of examples using system service calls.\nThe system service calls follow the standard calling convention in that the temporary \nregisters ($t0 - $t9) may be altered and the saved registers ($s0 - $s7, $fp, $ra) will be \npreserved.  As such, if a series of values is being printed in a loop, a saved register \nwould be required for the loop counter and the current array address/index.\n 9.2.1 Example Program, Display String and Integer\nThe following code provides an example of how to display a string and an integer.\n#  Example program to display a string and an integer.\n#  Demonstrates use of QtSpim system service calls.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nhdr:\n.ascii\n\"Example\\n\"\n.asciiz\n\"The meaning of life is: \"\nnumber:\n.word\n42\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\nla\n$a0, hdr\n# addr of NULL\n#   terminated string\nli\n$v0, 4\n# call code, print string\nsyscall\n# system call\nli\n$v0, 1\n# call code, print int\nlw\n$a0, number\n# value for int to print\nsyscall\n# system call\n# -----\n#  Done, terminate program.\nPage 85",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.65 sec"
    },
    {
      "page_number": 91,
      "text": "Chapter 9.0 ◄ QtSpim System Service Calls\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nNote, in this example, the string definition ensures the NULL termination as required by \nthe system service.\nThe output for the example would be displayed to the QtSpim console window.  For \nexample:\nThe console window can be displayed or hidden from the Windows menu (on the top \nbar).\n 9.2.2 Example Program, Display Array\nThis section provides an example of how to display an array.  In this example, an array \nof numbers is displayed to the screen with five numbers per line (arbitrarily chosen) to \nmake the output appear more pleasing.\nSince the system service call is utilized for the print function, the saved register must be \nused.  Refer to the Procedures/Functions section for additional information regarding the\nMIPS calling conventions.\n#  Example program to display an array.\n#  Demonstrates use of QtSpim system service calls.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nhdr:\n.ascii\n\"Array Values\\n\"\n.asciiz\n\"------------------------\\n\\n\"\nspaces:\n.asciiz\n\"   \"\nnewLine:\n.asciiz\n\"\\n\"\nPage 86",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page91_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page91_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "20.82 sec"
    },
    {
      "page_number": 92,
      "text": "Chapter  9.0 ► QtSpim System Service Calls\narray:\n.word\n11, 13, 15, 17, 19\n.word\n21, 23, 25, 27, 29\n.word\n31, 33, 35, 37, 39\n.word\n41, 43, 45, 47\nlength:\n.word\n19\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\nli\n$v0, 4\n# print header string\nla\n$a0, hdr\nsyscall\nla\n$s0, array\nli\n$s1, 0\nlw\n$s2, length\nprintLoop:\nli\n$v0, 1\n# call code for print int\nlw\n$a0, ($s0)\n# get array[i]\nsyscall\n# system call\nli\n$v0, 4\n# print spaces\nla\n$a0, spaces\nsyscall\naddu\n$s0, $s0, 4\n# update addr (next word)\nadd\n$s1, $s1, 1\n# increment counter\nrem\n$t0, $s1, 5\nbnez\n$t0, skipNewLine\nli\n$v0, 4\n# print new line\nla\n$a0, newLine\nsyscall\nskipNewLine:\nbne\n$s1, $s2, printLoop\n# if cnter<len -> loop\nPage 87",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "20.82 sec"
    },
    {
      "page_number": 93,
      "text": "Chapter 9.0 ◄ QtSpim System Service Calls\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nThe output for the example would be displayed to the QtSpim console window.\nFor example:\nThis example program does not align the values (when printed).  The values only appear\naligned since they all have the same number of digits.\n 9.2.3 Example Program, Read Integer\nThis section provides an example of how to display a prompt string, read an integer \nvalue, square that integer value, and display the final result.\nIt must be noted that the QtSpim read integer system service is fairly basic and does not \nperform error checking or handle backspace/delete.  As such, the number must be \nentered correctly by the user.  If invalid numbers, such as (a12 or 12q34) are entered, the\ninput will be mis-interpreted resulting in unexpected or invalid values.\nIf desired, the numeric input can be read as a string and converted into an integer with \nthe appropriate error handling.  This is left to the user as an exercise.\n#  Example program to display an array.\n#  Demonstrates use of QtSpim system service calls.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nPage 88",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page93_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page93_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "21.03 sec"
    },
    {
      "page_number": 94,
      "text": "Chapter  9.0 ► QtSpim System Service Calls\nhdr:\n.ascii\n\"Squaring Example\\n\"\n.asciiz\n\"Enter Value: \"\nansMsg:\n.asciiz\n\"Value Squared: \"\nvalue:\n.word\n0\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\nli\n$v0, 4\n# call code for print string\nla\n$a0, hdr\n# addr of NULL terminated str\nsyscall\n# system call\nli\n$v0, 5\n# call code for read integer\nsyscall\n# system call (result in $v0)\nmul\n$t0, $v0, $v0\n# square answer\nsw\n$t0, value\n# save to variable\nli\n$v0, 4\n# call code for print string\nla\n$a0, ansMsg\n# addr of NULL terminated str\nsyscall\n# system call\nli\n$v0, 1\n# call code for print integer\nlw\n$a0, value\n# value for integer to print\nsyscall\n# system call\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\nPage 89",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.03 sec"
    },
    {
      "page_number": 95,
      "text": "Chapter 9.0 ◄ QtSpim System Service Calls\nThe output for the example would be displayed to the QtSpim console window.  For \nexample:\nThe console window must be selected in order to enter input.  Note, the default console \nwindow size will typically be larger than what is shown above.\n 9.2.4 Example Program, Read String\nThis section provides an example of how to display a prompt string and read a string of \ncharacters.  As previously noted, at the assembly level, strings are a series of \ncontiguously defined byte-sized characters, typically terminated with a NULL byte \n(0x00).\nIn order to read a string, some space for where to place the characters read must be \ncreated.  The QtSpim system service for read string will always terminate the string with\na NULL byte which must be accommodated for in the space allocated.\nIn this example, a variable, userAns, was defined with fifty-two (52) bytes of space.  \nThis allows up to fifty (50) characters, a line feed (0x0A), and the NULL termination.  It\nshould be noted that if fifty-one (51) characters are entered, the input will be \nautomatically terminated, without the user pressing enter, and the NULL added to the \nstring.  This can very awkward when users are entering input, so input string sizes \nshould be chosen carefully.\nWhen the QtSpim system service is called, the string address (in $a0) and length (in \n$a1) must be provided.  It is important that the correct length be provided as an error \ncould result in memory, and thus other variables, being over-written.  Such problems \ncan be very difficult to find as the symptom will typically be in a different location than \nthe actual problem.\n# Example program to demonstrate string input\n# -----------------------------------------------------\n#  Data Declarations\nPage 90",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page95_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page95_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "21.21 sec"
    },
    {
      "page_number": 96,
      "text": "Chapter  9.0 ► QtSpim System Service Calls\n.data\nhdr:\n.ascii\n\"Reading Characters Example\\n\\n\"\n.asciiz\n\"Enter Your Name: \"\nhiMsg:\n.asciiz\n\"\\nHello, \"\nuserAns:\n.space\n52\n# -----------------------------------------------------\n#  text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\nli\n$v0, 4\n# call code, print string\nla\n$a0, hdr\n# addr of string\nsyscall\n# system call\nli\n$v0, 8\n# call code, read string\nla\n$a0, userAns\n# addr, where to put chars\nli\n$a1, 52\n# max chars for string\nsyscall\n# system call\nli\n$v0, 4\n# call code, print string\nla\n$a0, hiMsg\n# address string\nsyscall\n# system call\nli\n$v0, 4\n# call code, print string\nla\n$a0, userAns\n# address string\nsyscall\n# system call\nli\n$v0, 10\n# call code for terminate\nsyscall\n# system call\n.end main\nThe output and input for the example would be displayed to the QtSpim console \nwindow.\nPage 91",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.21 sec"
    },
    {
      "page_number": 97,
      "text": "Chapter 9.0 ◄ QtSpim System Service Calls\nFor example:\nThe console window must be selected in order to enter input.  Note, the default console \nwindow size will typically be larger than what is shown above.\nPage 92",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page97_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page97_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 98,
      "text": "10.0\nMulti-dimension Array Implementation\nThis chapter provides a summary of the implementation of multiple dimension arrays as\nviewed from assembly language.\nMemory is inherently a single dimension entity.  As such, a multi-dimension array is \nimplemented as sets of single dimension array.  There are two primary ways this can be \nperformed; row-major and column-major.  Each is explained in subsequent sections.\nTo simplify the explanation, this section focuses on two-dimensional arrays.  The \ngeneral process extends to higher dimensions.\n 10.1 \nHigh-Level Language View\nMulti-Dimension arrays are sometimes used in high-level languages.  For example, in \nC/C++, the declaration of:   int arr [3][4]  would declare an array as follows:\narr[2][0] arr[2][1] arr[2][2] arr[2][3]\narr[1][0] arr[1][1] arr[1][2] arr[1][3]\narr\narr[0][0] arr[0][1] arr[0][2] arr[0][3]\nIt is expected that the reader is generally familiar with the high-level language use of \ntwo-dimensional arrays.\nPage 93",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 99,
      "text": "Chapter 10.0 ◄ Multi-dimension Array Implementation\n 10.2 \nRow-Major\nRow-major assigns each row as a single dimension array in memory, one row after the \nnext until all rows are in memory.\n11\narr[2][3]\n10\narr[2][2]\n9\narr[2][1]\narr\n8\narr[2][0]\n8\n9\n10\n11\n7\narr[1][3]\n4\n5\n6\n7\n6\narr[1][2]\n0\n1\n2\n3\n5\narr[1][1]\n4\narr[1][0]\n3\narr[0][3]\n2\narr[0][2]\n1\narr[0][1]\n0\narr[0][0]\nThe formula to convert two-dimensional array indexes (row, column) into a single \ndimension, row-major memory offset is as follows:\n  addr = baseAddr + (rowIdx * numOfCols + colIdx) * dataSize\nWhere the base address is the starting address of the array, dataSize is the size of the \ndata in bytes, and numOfCols is the dimension or number of the columns in the two-\ndimension array.  In this example, the number of columns in the array is 4 (from the \nprevious high-level language declaration).\nFor example, to access the  arr[1][2]  element (labeled '6' in the above diagram), \nassuming the array is composed of 32-bit sized elements it would be:\naddress  = arr + (1 * 4 + 2) * 4 = arr + (4 + 2) * 4\n    = arr + 6 * 4 = arr + 24\nWhich generates the correct, final address.\nPage 94",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 100,
      "text": "Chapter  10.0 ► Multi-dimension Array Implementation\n 10.3 \nColumn-Major\nColumn-major assigns each column as a single dimension array in memory, one column \nafter the next until all rows are in memory.\n11\narr[2][3]\n10\narr[1][3]\n9\narr[0][3]\narr\n8\narr[2][2]\n2\n5\n8\n11\n7\narr[1][2]\n1\n4\n7\n10\n6\narr[0][2]\n0\n3\n6\n9\n5\narr[2][1]\n4\narr[1][1]\n3\narr[0][1]\n2\narr[2][0]\n1\narr[1][0]\n0\narr[0][0]\nThe formula to convert two-dimensional array indexes (row, column) into a single \ndimension, column-major memory offset is as follows:\n     addr = baseAddr + (colIdx * numOfRows + rowIdx) * dataSize\nWhere the base address is the starting address of the array, dataSize is the size of the \ndata in bytes, and numOfRows is the dimension or number of the rows in the two-\ndimension array.  In this example, the number of rows in the array is 3 (from the \nprevious high-level language declaration).\nFor example, to access the  arr[1][2]  element (labeled '7' in the above diagram), \nassuming the array is composed of 32-bit sized elements it would be:\naddress  = arr + (2 * 3 + 1) * 4 = arr + (6 + 1) * 4\n    = arr + 7 * 4 = arr + 28\nWhich generates the correct, final address.\nPage 95",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 101,
      "text": "Chapter 10.0 ◄ Multi-dimension Array Implementation\n 10.4 \nExample Program, Matrix Diagonal Summation\nThe following code provides an example of how to access elements in a two-\ndimensional array.  This example adds the elements on the diagonal of a two-\ndimensional array.\nFor example, given the logical view of a five-by-five square matrix:\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nThe main diagonal contains the numbers, 11, 17, 23, 29, and 35.\n#  Example program to compute the sum of diagonal\n#  in a square two-dimensional, row-major array\n#  Demonstrates multi-dimension array indexing.\n#  Assumes row-major ordering.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nmdArray:\n.word\n11, 12, 13, 14, 15\n.word\n16, 17, 18, 19, 20\n.word\n21, 22, 23, 24, 25\n.word\n26, 27, 28, 29, 30\n.word\n31, 32, 33, 34, 35\nsize:\n.word\n5\ndSum:\n.word\n0\nDATASIZE = 4\n# 4 bytes for words\nfinalMsg:\n.ascii\n\"Two-Dimensional Diagonal\" \n.ascii\n\"Summation\\n\\n\"\n.asciiz\n\"Diagonal Sum = \"\n# -----------------------------------------------------\nPage 96",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 102,
      "text": "Chapter  10.0 ► Multi-dimension Array Implementation\n#  Text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Call function to sum the diagonal\n#\n(of square two-dimensional array)\nla\n$a0, mdArray\n# base address of array\nlw\n$a1, size\n# array size\njal\ndiagSummer\nsw\n$v0, dSum\n# -----\n#  Display final result.\nli\n$v0, 4\n# print prompt string\nla\n$a0, finalMsg\nsyscall\nli\n$v0, 1\n# print integer\nlw\n$a0, dSum\nsyscall\n# -----\n# Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\n# -----------------------------------------------------\n#  Simple function to sum the diagonals of a\n#  square two-dimensional array.\n#  Approach\n#\nloop i = 0 to len-1\n#\nsum = sum + mdArray[i][i]\n#  Note, for two-dimensional array:\nPage 97",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 103,
      "text": "Chapter 10.0 ◄ Multi-dimension Array Implementation\n#   addr = baseAddr + (rowIdx * numOfCols + colIdx)\n#\n* dataSize\n#  Since the two-dimensional array is given as square, \n#  the row and column dimensions are the same size.\n# -----\n#  Arguments\n#\n$a0 - array base address\n#\n$a1 - size (of square two-dimension array)\n#  Returns\n#\n$v0 - sum of diagonals\n.globl\ndiagSummer\n.ent\ndiagSummer\ndiagSummer:\nli\n$v0, 0\n# sum=0\nli\n$t1, 0\n# loop index, i=0\ndiagSumLoop:\nmul\n$t3, $t1, $a1\n# (rowIdx * colSize\nadd\n$t3, $t3, $t1\n#              + colIdx)\n# note, rowIdx=colIdx\nmul\n$t3, $t3, DATASIZE\n#              * dataSize\nadd\n$t4, $a0, $t3\n# + base address\nlw\n$t5, ($t4)\n# get mdArray[i][i]\nadd\n$v0, $v0, $t5\n# sum = sum+mdArray[i][i]\nadd\n$t1, $t1, 1\n# i = i + 1\nblt\n$t1, $a1, diagSumLoop\n# -----\n#  Done, return to calling routine.\njr\n$ra\n.end\ndiagSummer\nWhile not mathematically useful, this does demonstrate how elements in a two-\ndimensional array are accessed.\nPage 98",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 104,
      "text": "11.0\nRecursion\nThe Google search result for recursion, shows \"Did you mean: Recursion\".\nRecursion is the idea that a function may call itself (which is the basis for the joke).  \nRecursion is a powerful general-purpose programming technique and is used for some \nimportant applications including searching and sorting.\nRecursion can be very confusing in its simplicity.  The simple examples in this section \nwill not be enough in themselves for the reader to obtain recursive enlightenment.  The \ngoal of this section is to provide some insight into the underlying mechanisms that \nsupport recursion.  The simple examples here which are used to introduce recursion are \nmeant to help demonstrate the form and structure for recursion.  More complex \nexamples (than will be discussed here) should be studied and implemented in order to \nensure a complete appreciation for the power of recursion.\nThe procedure/function calling process previously described supports recursion without \nany changes.\nA recursive function must have a recursive definition that includes:\n1. Base case, or cases, that provide a simple result (that defines when the recursion \nshould stop).\n2. Rule, or set of rules, that reduce toward the base case.\nThis definition is referred to as a recursive relation.\n 11.1 \nRecursion Example, Factorial\nThe factorial function is mathematically defined as follows:\nn! = ∏\nk=1\nn\nk\nOr more familiarly, you might see 5! as:\n5! = 5 × 4 × 3 × 2 × 1\nIt must be noted that this function could easily be computed with a loop.  However, the \nreason this is done recursively is to provide a simple example of how recursion works. \nPage 99",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 105,
      "text": "Chapter 11.0 ◄ Recursion\nA typical recursive definition for factorial is:\nfactorial(n) = {\n1\nif n=0\nn × factorial(n−1)\nif n≥1\nThis definition assumes that the value of n is positive.\n 11.1.1 \nExample Program, Recursive Factorial Function\nThe following code provides an example of the recursive factorial function.\n#  Example program to demonstrate recursion.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nprompt:\n.ascii\n\"Factorial Example Program\\n\\n\"\n.asciiz\n\"Enter N value: \"\nresults:\n.asciiz\n\"\\nFactorial of N = \"\nn:\n.word 0\nanswer:\n.word 0\n# -----------------------------------------------------\n#  Text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Read n value from user\nli\n$v0, 4\n# print prompt string\nla\n$a0, prompt\nsyscall\nli\n$v0, 5\n# read N (as integer)\nPage 100",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 106,
      "text": "Chapter  11.0 ► Recursion\nsyscall\nsw\n$v0, n\n# -----\n#  Call factorial function.\nlw\n$a0, n\njal\nfact\nsw\n$v0, answer\n# -----\n#  Display result\nli\n$v0, 4\n# print prompt string\nla\n$a0, results\nsyscall\nli\n$v0, 1\n# print integer\nlw\n$a0, answer\nsyscall\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# call code for terminate\nsyscall\n# system call\n.end main\n# -----------------------------------------------------\n#  Factorial function\n#  Recursive definition:\n#\n= 1               if n = 0\n#\n= n * fact(n-1)   if n >= 1\n# -----\n#  Arguments\n#\n$a0 - n\n#  Returns\n#\n$v0 set to n!\n.globl\nfact\n.ent\nfact\nfact:\nPage 101",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.41 sec"
    },
    {
      "page_number": 107,
      "text": "Chapter 11.0 ◄ Recursion\nsubu\n$sp, $sp, 8\nsw\n$ra, ($sp)\nsw\n$s0, 4($sp)\nli\n$v0, 1\n# check base case\nbeq\n$a0, 0, factDone\nmove\n$s0, $a0\n# fact(n-1)\nsub\n$a0, $a0, 1\njal\nfact\nmul\n$v0, $s0, $v0\n# n * fact(n-1)\nfactDone:\nlw\n$ra, ($sp)\nlw\n$s0, 4($sp)\naddu\n$sp, $sp, 8\njr\n$ra\n.end\nfact\nThe output for the sample program would be displayed to the QtSpim console window.  \nFor example:\nRefer to the next section for an explanation of how this function works.\nPage 102",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page107_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page107_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "21.61 sec"
    },
    {
      "page_number": 108,
      "text": "Chapter  11.0 ► Recursion\n 11.1.2 \nRecursive Factorial Function Call Tree\nIn order to help understand recursion, a recursion tree can show how the recursive calls \ninteract.\nWhen the initial call occurs from main, the main will start into the fact() function \n(shown as step 1).  Since the argument of 5 is not a base case, the fact() function must \ncall fact() again with the argument of n-1 or 4 in this example (step 2).  And, again, \nsince 4 is not the base case, the fact() function must call fact() again with the argument \nof n-1 or 3 in this example (step 3).\nThis process continues until the argument passed into the fact() function meets the base \ncase which is when the argument is equal to 1 (shown as step 5).  When this occurs, only\nthen is a return value provided to the previous call (step 6).  This return argument is then\nPage 103\nfact:\n    5 * fact(4)\nfact:\n    4 * fact(3)\nfact:\n    3 * fact(2)\nmain:\n    f = fact(5)\nfact:\n    2 * fact(1)\nfact:\n    return 1\nStep 1\nStep 2\nStep 3\nStep 4\nStep 5\nStep 6\nStep 7\nStep 8\nStep 9\nStep 10",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.61 sec"
    },
    {
      "page_number": 109,
      "text": "Chapter 11.0 ◄ Recursion\nused to calculate the previous multiplication which is 2 times 1 which will return a value\nto the previous call (as shown in step 7).\nThese returns will continue (steps 8, 9, and 10) until the main has a final answer.\nSince the code being executed is the same, each instance of the fact() function is \ndifferent from any other instance only in the arguments and temporary values.  The \narguments and temporary values for each instance are different since they are \nmaintained on the stack as required by the standard calling convention.\nFor example, consider a call to factorial with n = 2 (step 4 on the diagram).  The return \naddress, $ra, and previous contents of $s0 are preserved by pushing them on the stack in\naccordance with the standard calling convention.  The base case is checked and since  n \n≠ 1 it continues to save the original value of 1 into $s0, decrements the original \nargument, n, by 1 and calls the fact() function (with n = 1).  The call for the fact() \nfunction (step 5 in the diagram) is like any other function call in that it must follow the \nstandard calling convention, which requires preserving $ra and $s0 (since they are \nchanged).  This is when the function returns an answer, 1 in this specific case, that \nanswer in $v0 is then multiplied by the original n value in $s0 and returned to the \ncalling routine.\nAs such, the foundation for recursion is the procedure call frame or activation record.  In\ngeneral, it can be simply stated that recursion is stack-based.\nIt should also be noted that the height of the recursion tree is directly associated with the\namount of stack memory used by the function.\n 11.2 \nRecursion Example, Fibonacci\nThe Fibonacci function is mathematically defined as follows:\nFn = Fn−1 + Fn−2\nfor positive integers with seed values of F0 = 0 and F1 = 1 by definition.\nAs such, starting from 0 the first 14 numbers in the Fibonacci series are:\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233\nIt must be noted that this function could easily be computed with a loop.  However, the \nreason this is done recursively is to provide a simple example of how recursion works. \nPage 104",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.61 sec"
    },
    {
      "page_number": 110,
      "text": "Chapter  11.0 ► Recursion\nFor example, a typical recursive definition for Fibonacci is:\nfib(n) = {\n0\nif n=0\n1\nif n=1\nfib( n−1) + fib( n−2)\nif n>1\nThis definition assumes that the value of n is positive.\n 11.2.1 \nExample Program, Recursive Fibonacci Function\nThe following code provides an example of the recursive Fibonacci function.\n#  Recursive Fibonacci program to demonstrate recursion.\n# -----------------------------------------------------\n#  Data Declarations\n.data\nprompt:\n.ascii\n\"Fibonacci Example Program\\n\\n\"\n.asciiz\n\"Enter N value: \"\nresults:\n.asciiz\n\"\\nFibonacci of N = \"\nn:\n.word 0\nanswer:\n.word 0\n# -----------------------------------------------------\n#  Text/code section\n.text\n.globl\nmain\n.ent\nmain\nmain:\n# -----\n#  Read n value from user\nli\n$v0, 4\n# print prompt string\nla\n$a0, prompt\nsyscall\nPage 105",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.61 sec"
    },
    {
      "page_number": 111,
      "text": "Chapter 11.0 ◄ Recursion\nli\n$v0, 5\n# read N (as integer)\nsyscall\nsw\n$v0, n\n# -----\n#  Call Fibonacci function.\nlw\n$a0, n\njal\nfib\nsw\n$v0, answer\n# -----\n#  Display result\nli\n$v0, 4\n# print prompt string\nla\n$a0, results\nsyscall\nli\n$v0, 1\n# print integer\nlw\n$a0, answer\nsyscall\n# -----\n#  Done, terminate program.\nli\n$v0, 10\n# terminate\nsyscall\n# system call\n.end main\n# -----------------------------------------------------\n#  Fibonacci function\n#  Recursive definition:\n#\n= 0                     if n = 0\n#\n= 1                     if n = 1\n#\n= fib(n-1) + fib(n-2)   if n > 2\n# -----\n#  Arguments\n#\n$a0 - n\n#  Returns\n#\n$v0 set to fib(n)\n.globl\nfib\n.ent\nfib\nPage 106",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.61 sec"
    },
    {
      "page_number": 112,
      "text": "Chapter  11.0 ► Recursion\nfib:\nsubu\n$sp, $sp, 8\nsw\n$ra, ($sp)\nsw\n$s0, 4($sp)\nmove\n$v0, $a0\n# check for base cases\nble\n$a0, 1, fibDone\nmove\n$s0, $a0\n# get fib(n-1)\nsub\n$a0, $a0, 1\njal\nfib\nmove\n$a0, $s0\nsub\n$a0, $a0, 2\n# set n-2\nmove\n$s0, $v0\n# save fib(n-1)\njal\nfib\n# get fib(n-2)\nadd\n$v0, $s0, $v0\n# fib(n-1)+fib(n-2)\nfibDone:\nlw\n$ra, ($sp)\nlw\n$s0, 4($sp)\naddu\n$sp, $sp, 8\njr\n$ra\n.end\nfib\nThe output for the example would be displayed to the QtSpim console window.\nFor example:\nRefer to the next section for an explanation of how this function works.\nPage 107",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page112_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page112_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "21.81 sec"
    },
    {
      "page_number": 113,
      "text": "Chapter 11.0 ◄ Recursion\n 11.2.2 \nRecursive Fibonacci Function Call Tree\nThe Fibonacci recursion tree appears more complex than the previous factorial tree since\nthe Fibonacci function uses two recursive calls.  However, the general process and use \nof the stack for arguments and temporary values is the same.\nAs noted in the factorial example, the basis of recursion is the stack.  In this example, \nsince two recursive calls are made, the first call will make another call, which may make\nyet another call.  In this manner, the call sequence will follow the order shown in the \nfollowing diagram.\nPage 108",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.81 sec"
    },
    {
      "page_number": 114,
      "text": "Chapter  11.0 ► Recursion\nThe following is an example of the call tree for a Fibonacci call with n = 4.\nThe calls are shown with a solid line and the returns are shown with a dashed line.\nPage 109\nstep 1\nstep 2\nstep 3\nstep 4\nstep 5\nstep 6\nstep 7\nstep 8\nstep 9\nstep 10\nstep 11\nstep 7\nfib:\n  return 1\nfib:\n  fib(1) + \n       fib(0)\nfib:\n  return 1\nfib:\n  return 0\nfib:\n  return 1\nfib:\n  return 0\nfib:\n  fib(2) + \n       fib(1)\nfib:\n  fib(1) + \n       fib(0)\nfib:\n  fib(3) + \n       fib(2)\nmain:\n  fib(4)\nstep 12\nstep 13\nstep 14\nstep 15\nstep 16",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.81 sec"
    },
    {
      "page_number": 115,
      "text": "Chapter 11.0 ◄ Recursion\nPage 110",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.81 sec"
    },
    {
      "page_number": 116,
      "text": "12.0\nAppendix A – Example Program\nBelow is a simple example program.  This program can be used to test the simulator \ninstallation and as an example of the required program formatting.\n#  Example program to find the minimum and maximum from\n#  a list of numbers.\n# ----------------------------------------------------\n#  data segment\n.data\narray:\n.word\n13, 34, 16, 61, 28\n.word\n24, 58, 11, 26, 41\n.word\n19,  7, 38, 12, 13\nlen:\n.word\n15\nhdr:\n.ascii\n\"\\nExample program to find max and\"\n.asciiz\n\" min\\n\\n\"\nnewLine:\n.asciiz\n\"\\n\"\na1Msg:\n.asciiz\n\"min = \"\na2Msg:\n.asciiz\n\"max = \"\n# ----------------------------------------------------\n#  text/code segment\n#  QtSpim requires the main procedure be named \"main\".\n.text\n.globl\nmain\n.ent\nmain\nmain:\n#  This program will use pointers.\n#\nt0 - array address\n#\nt1 - count of elements\n#\ns2 - min\n#\ns3 - max\nPage 111",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.81 sec"
    },
    {
      "page_number": 117,
      "text": "Appendix A – Example Program\n#\nt4 - each word from array\n# -----\n#  Display header\n#  Uses print string system call\nla\n$a0, hdr\nli\n$v0, 4\nsyscall\n# print header\n# -----\n#  Find max and min of the array.\n#   Set min and max to first item in list and then\n#   loop through the array and check min and max \n#   against each item in the list, updating the min\n#   and max values as needed.\nla\n$t0, array\n# $t0 addr of array\nlw\n$t1, len\n# $t1 to length\nlw\n$s2, ($t0)\n# min, $s2 to array[0]\nlw\n$s3, ($t0)\n# max, $s3 to array[0]\nloop:\nlw\n$t4, ($t0)\n# get array[n]\nbge\n$t4, $s2, NotMin# is new min?\nmove\n$s2, $t4\n# set new min\nNotMin:\nble\n$t4, $s3, NotMax# is new max?\nmove\n$s3, $t4\n# set new max\nNotMax:\nsub\n$t1, $t1, 1\n# decrement counter\naddu\n$t0, $t0, 4\n# increment addr by word\nbnez\n$t1, loop\n# -----\n#  Display results min and max.\n#   First display string, then value, then a print a\n#   new line (for formatting). Do for each max and min.\nla\n$a0, a1Msg\nli\n$v0, 4\nsyscall\n# print \"min = \"\nPage 112",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.82 sec"
    },
    {
      "page_number": 118,
      "text": "Appendix A – Example Program\nmove\n$a0, $s2\nli\n$v0, 1\nsyscall\n# print min\nla\n$a0, newLine\n# print a newline\nli\n$v0, 4\nsyscall\nla\n$a0, a2Msg \nli\n$v0, 4 \nsyscall\n# print \"max = \" \nmove\n$a0, $s3 \nli\n$v0, 1 \nsyscall\n# print max \nla\n$a0, newLine\n# print a newline \nli\n$v0, 4 \nsyscall \n# ----- \n#  Done, terminate program. \nli\n$v0, 10 \nsyscall\n# all done! \n.end main \nPage 113",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.82 sec"
    },
    {
      "page_number": 119,
      "text": "Appendix A – Example Program\nPage 114",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.82 sec"
    },
    {
      "page_number": 120,
      "text": "13.0\nAppendix B – QtSpim Tutorial\nThis QtSpim Tutorial is designed to prepare you to use the QtSpim simulator and \ncomplete your MIPS assignments more easily.\n 13.1 \nDownloading and Installing QtSpim\nThe first step is to download and install QtSpim for your specific machine.  QtSpim is \navailable for Windows, Linux, and MAC OS's.\n 13.1.1 \nQtSpim Download URLs\nThe following are the current URLs for QtSpim.\nThe QtSpim home page is located at:\nhttp://spimsimulator.sourceforge.net/\nThe specific download site is located at:\nhttp://sourceforge.net/projects/spimsimulator/files/\nAt the download site there are multiple versions for different target machines.  These \ninclude Windows (all versions), Linux/Ubuntu (32-bit), Linux/Ubuntu (64-bit), and Mac\nOS (all versions).  Download the latest version for your machine.\nThese URLs are subject to change.  If they do not work, a Google search will find the \ncorrect URLs.\n 13.1.2 \nInstalling QtSpim\nOnce the package is downloaded, follow the standard installation process for the \nspecific OS being used.  This typically will involve double-clicking the downloaded \ninstallation package and following the instructions.  You will need administrator \nprivileges to perform the installation.  Additionally, some installations will require \nInternet access during the installation.\nPage 115",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.82 sec"
    },
    {
      "page_number": 121,
      "text": "Appendix B – QtSpim Tutorial\n 13.2 \nWorking Directory\nCreate a working directory for the QtSpim assembly source files.  This directory can be \nnamed anything, but must be legal on the chosen operating system.\n 13.3 \nSample Program\nCopy or type the provided example program (from Appendix A) to a file in your \nworking directory.  This file will be used in the remainder of the tutorial.  It \ndemonstrates assembler directives, procedure calls, console I/O, program termination, \nand good programming practice.  Notice in particular the assembler directives '.data' and\n'.text' as well as the declarations of program constants.  Understanding the basic flow of \nthe example program will help you to complete your SPIM assignment quickly and \npainlessly.  Once you have created the file and reviewed the code, it is time to move \nonto the next section.\n 13.4 \nQtSpim – Loading and Executing Programs\nAfter the QtSpim application installation has been complete and the sample program has\nbeen created, you can execute the program to view the results.  The use of QtSpim is \ndescribed in the following sections.\n 13.4.1 \nStarting QtSpim\nFor Windows, this is typically performed with the standard \"Start Menu -> Programs -> \nQtSpim\" operation.  For macOS, enter LaunchPad and click on QtSPim.  For Linux, \nfind the QtSpim icon (location is OS distribution dependent) and click on QtSpim.\nPage 116",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "21.82 sec"
    },
    {
      "page_number": 122,
      "text": "Appendix B – QtSpim Tutorial\n 13.4.2 \nMain Screen\nThe initial QtSpim screen will appear as shown below.  There will be some minor \ndifferences based on the specific Operating System being used.\n 13.4.3 \nLoad Program\nTo load the example program (and all programs), you can select the standard \n\"File→Reinitialize and Load File\" option from the menu bar.  However, it is typically \neasier to select the Reinitialize and Load File Icon from the main screen (second file \nicon on the top left side).\nPage 117",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page122_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page122_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "23.45 sec"
    },
    {
      "page_number": 123,
      "text": "Appendix B – QtSpim Tutorial\nNote, the Load File option can be used on the initial load, but subsequent file loads will \nneed to use the Reinitialize and Load File to ensure the appropriate reinitialization \noccurs.\nOnce selected, a standard open file dialog box will be displayed.  Find and select \n'asst0.asm' file (or whatever you named it) created in section 3.0.\nNavigate as appropriate to find the example file previously created.  When found, select \nthe file (it will be highlighted) and click Open button (lower right hand corner).\nPage 118\nReinitialize and Load File Icon",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page123_img1.jpeg",
        "output\\images\\MIPS_Assembly_Language_small_163_page123_img2.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page123_img1_summary.json",
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page123_img2_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "25.43 sec"
    },
    {
      "page_number": 124,
      "text": "Appendix B – QtSpim Tutorial\nThe assembly process occurs as the file is being loaded.  As such, any assembly syntax \nerrors (i.e., misspelled instructions, undefined variables, etc.) are caught at this point.  \nAn appropriate error message is provided with a reference to the line number that \ncaused the error.\nWhen the file load is completed with no errors, the program is ready to run, but has not \nyet been executed.  The screen will appear something like the following image.\nThe code is placed in Text Window.  The first column of hex values (in the []'s) is the \naddress of that line of code.  The next hex value is the OpCode or hex value of the 1's \nand 0's that the CPU understands to be that instruction.\nPage 119\nAddresses          OpCodes          Bare-Instructions          Pseudo-Instructions",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page124_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page124_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "27.37 sec"
    },
    {
      "page_number": 125,
      "text": "Appendix B – QtSpim Tutorial\nMIPS includes pseudo-instructions.  That is an instruction that the CPU does not \nexecute, but the programmer is allowed to use.  The assembler, QtSpim here, accepts the\ninstruction and inserts the real or bare instruction as appropriate.\n 13.4.4 \nData Window\nThe data segment contains the data declared by your program (if any).  To view the data\nsegment, click on the Data Icon.  The data window will appear similar to the following:\nAs before, the addresses are shown on the left side (with the []'s).  The values at that \naddress are shown in hex (middle) and in ASCII (right side).  Depending on the specific \ntype of data declarations, it may be easier to view the hex representation (i.e., like the \nPage 120\nAddresses           Data (Hex Representation)            Data (ASCII Representation)",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page125_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page125_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "30.27 sec"
    },
    {
      "page_number": 126,
      "text": "Appendix B – QtSpim Tutorial\narray of numbers from the example code) or the ASCII representation (i.e., the declared \nstrings).\nNote, right clicking in the Data Window will display a menu allowing the user to change\nthe default hex representation to decimal representation (if desired).\n 13.4.5 \nProgram Execution\nTo execute the entire program (uninterrupted), you can select the standard \"Simulator \n→ Run/Continue\" option from the menu bar.  However, it is typically easier to select \nthe Run/Continue Icon from the main screen or to type the F5 key.\nOnce typed, the program will be executed.\nIf a program performs input and/or output, it will be directed to the Console window.  \nPage 121\nRun/Continue",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page126_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page126_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "32.18 sec"
    },
    {
      "page_number": 127,
      "text": "Appendix B – QtSpim Tutorial\nFor example, the sample program (from Appendix A) will display the following in the \nConsole window when executed.\nFor the sample program and the initial data set, these are the correct results.\n 13.4.6 \nLog File\nQtSpim can create a log file saving and documenting the program results.  To create a \nlog file, you can select the standard \"File → Save Log File\" option from the menu bar.  \nHowever, it is typically easier to select the Save Log File Icon from the main screen.\nPage 122\nSave Log File",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page127_img1.jpeg",
        "output\\images\\MIPS_Assembly_Language_small_163_page127_img2.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page127_img1_summary.json",
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page127_img2_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "34.01 sec"
    },
    {
      "page_number": 128,
      "text": "Appendix B – QtSpim Tutorial\nWhen selected, the Save Windows to Log File dialog box will be displayed as shown \nbelow on the left.\nIn general, the Text Segments and Console options should be selected as shown on the \nleft.\nAdditionally, there is no default file name or location (for the log file).  As such, a file \nname must be entered before it can be saved.  This can be done by manually entering the\nname in the Save to file box or by selecting the  …  box (on the lower right side).\nPage 123",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page128_img1.jpeg",
        "output\\images\\MIPS_Assembly_Language_small_163_page128_img2.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page128_img1_summary.json",
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page128_img2_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "34.47 sec"
    },
    {
      "page_number": 129,
      "text": "Appendix B – QtSpim Tutorial\nWhen the … option is selected, a Save to Log File dialog box is displayed allowing \nselection of a location and the entry of a file name.\nWhen completed correctly, the Save Windows To Log File box will appear similar the \nbelow image.\nWhen the options are selected and the file name entered, the OK box can be selected \nwhich will save the log file.\nPage 124",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page129_img1.jpeg",
        "output\\images\\MIPS_Assembly_Language_small_163_page129_img2.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page129_img1_summary.json",
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page129_img2_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "35.01 sec"
    },
    {
      "page_number": 130,
      "text": "Appendix B – QtSpim Tutorial\n 13.4.7 \nMaking Updates\nIn the highly unlikely event that the program does not work the first time or the program\nrequirements are changed, the source file will need to be updated in a text editor.  After \nthe program source file is updated, it must be explicitly reloaded into QtSpim.  The \nReinitialize and Load File option must be used as described in section 13.4.3.  Every \nchange made to the source file must be re-loaded into QtSpim.\nOnce re-loaded, the program can be re-executed as noted in section 13.4.5.  Refer to \nsection 5.0 for information regarding debugging and controlling program execution.\n 13.5 \nDebugging\nOften, looking at program source code will not help to find errors.  The first step in \ndebugging is to ensure that the file assembles correctly (or \"reads\" in the specific case of\nQtSpim).  However, even if the file assembles, it still may not work correctly.  In this \ncase, the program must be debugged.  In a broad sense, debugging is comparing the \nexpected program results to actual program results.  This requires a solid understanding \nof what the program is supposed to do and the specific order in which it does it → that \nis understanding the algorithm being used to solve the program.  The algorithm should \nbe noted in the program comments and can be used as a checklist for the debugging \nprocess.\nPage 125",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "35.01 sec"
    },
    {
      "page_number": 131,
      "text": "Appendix B – QtSpim Tutorial\nOne potentially useful way to check the program status is to view the register contents.  \nThe current register contents are shown in registers window (left side) as shown in the \nimage below.\nThe overall debugging process can be simplified by using the QtSpim controlled \nexecution functions.  These functions include single stepping through the program and \nusing one or more breakpoints.  A breakpoint is a programmer selected location in the \nprogram where execution will be paused.  When the program is paused the current \nprogram status can be checked by viewing the register contents and/or the data segment.\nTypically, a breakpoint will be set, the program executed (to that point), and from there \nsingle stepping through the program watching execution and checking the results (via \nregister contents and/or data segment).\nWhen stepping through the program, the next instruction to be executed is highlighted.  \nAs such, that instruction has not yet been executed.  This highlighting is how to track \nthe progress of the program execution.\nTo set a breakpoint, select an appropriate location.  This should be chosen with a \nspecific expectation in mind.  For example, if a program does not produce the correct \naverage for a list of numbers, a typical debugging strategy would be to see if the sum is \ncorrect (as it is required for the average calculation).  As such, a breakpoint could be set \nafter the loop and before the average calculation.\nPage 126\nRegister Window",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page131_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page131_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "36.62 sec"
    },
    {
      "page_number": 132,
      "text": "Appendix B – QtSpim Tutorial\nAs an example, to set a breakpoint after the loop in the sample program (from Appendix\nA), the first instruction after the loop can be found in the Text Window.  This will \nrequire looking at the pseudo-instructions (on the right side of the Text Window).\nThe first instruction after the loop in the example program is highlighted in orange (for \nreference) in the image below.\nNote, the orange highlighting was added to this document for reference and will not be \ndisplayed in QtSpim during normal execution.\nPage 127",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page132_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page132_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "38.78 sec"
    },
    {
      "page_number": 133,
      "text": "Appendix B – QtSpim Tutorial\nWhen an appropriate instruction is determined, move the cursor to the instruction \naddress and right-click.  The right-click will display the breakpoint menu as shown in \nthe image below.\nTo set a breakpoint, select the Set Breakpoint option.  If a breakpoint has already been \nset, it can be cleared by selecting the Clear Breakpoint option.\nPage 128",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page133_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page133_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "40.34 sec"
    },
    {
      "page_number": 134,
      "text": "Appendix B – QtSpim Tutorial\nOnce the breakpoint has been set, it will be highlighted with a small red icon such as an \nN as shown in the following image.  Note, different operating systems may use a \ndifferent icon.\nSelect the Run/Continue option (as described in section 13.4.5) which will execute the \nprogram up to the selected breakpoint.\nPage 129",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page134_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page134_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "42.41 sec"
    },
    {
      "page_number": 135,
      "text": "Appendix B – QtSpim Tutorial\nWhen program execution reaches the breakpoint, it will be paused and a Breakpoint \ndialog box displayed as shown in the below image.\nThe program execution can be halted by selecting the Abort box.  The breakpoint can be\nignored, thus continuing to the next breakpoint or program termination, whichever \ncomes first.\nPage 130",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page135_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page135_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "42.62 sec"
    },
    {
      "page_number": 136,
      "text": "Appendix B – QtSpim Tutorial\nHowever, typically the Single Step box will be selected upon entering the single step \nmode.  The following image shows the result of selecting Single Step.  Note, the \nhighlighted instruction represents the next instruction to be executed and thus has not \nyet been executed.\nPage 131",
      "tables": "No table support in fitz.",
      "images": [
        "output\\images\\MIPS_Assembly_Language_small_163_page136_img1.jpeg"
      ],
      "img_summary_files": [
        "output\\images\\img_summary\\MIPS_Assembly_Language_small_163_page136_img1_summary.json"
      ],
      "img_vision_files": [],
      "time_taken": "44.42 sec"
    },
    {
      "page_number": 137,
      "text": "Appendix B – QtSpim Tutorial\nPage 132",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.42 sec"
    },
    {
      "page_number": 138,
      "text": "14.0\nAppendix C – MIPS Instruction Set\nThis appendix presents a summary of the MIPS instructions as implemented within the \nQtSpim simulator.  The instructions are grouped by like-operations and presented \nalphabetically.\nThe following table summarizes the notational conventions used.\nOperand Notation\nDescription\nRdest\nDestination operand.  Must be a register.  Since it is a\ndestination operand, the contents will be over written \nwith the new result.\nFRdest\nDestination operand.  Must be a floating-point \nregister.  Since it is a destination operand, the \ncontents will be over written with the new result.\nRsrc\nSource operand.  Must be a register.  Register value \nis unchanged.\nFRsrc\nSource operand.  Must be a floating-point register.  \nRegister value is unchanged.\nSrc\nSource operand.  Must be a register or an immediate \nvalue.  Value is unchanged. \nImm\nImmediate value\nMem\nMemory location.  May be a variable name or an \nindirect reference.\nRefer to the chapter on Addressing Modes for more information regarding indirection.\nPage 133",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.42 sec"
    },
    {
      "page_number": 139,
      "text": "Appendix C – MIPS Instruction Set\n 14.1 \nArithmetic Instructions\nBelow are a summary of the basic integer arithmetic instructions.\nabs    Rdest, Rsrc\nAbsolute Value\nSets Rdest = absolute value of integer in \nRsrc\nadd    Rdest, Rsrc, Src\nAddition (with overflow)\nSets Rdest = Rsrc + Src (or imm)\naddu   Rdest, Rsrc, Src\nAddition (without overflow)\nSets Rdest = Rsrc + Src (or imm)\ndiv    Rsrc1, Rsrc2\nDivide (with overflow)\nSet $lo = Rsrc / Src (or imm)\nRemainder is placed in $hi\ndivu   Rsrc1, Rsrc2\nDivide (without overflow)\nSet $lo = Rsrc / Src (or imm)\nRemainder is placed in $hi\ndiv    Rdest, Rsrc, Src\nDivide (with overflow)\nSets: Rdest = Rsrc / Src (or imm)\ndivu   Rdest, Rsrc, Src\nDivide (without overflow)\nSets: Rdest = Rsrc / Src (or imm)\nmul    Rdest, Rsrc, Src\nMultiply (without overflow)\nSets: Rdest = Rsrc ( Src (or imm)\nmulo   Rdest, Rsrc, Src\nMultiply (with overflow)\nSets: Rdest = Rsrc * Src (or imm)\nPage 134",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.42 sec"
    },
    {
      "page_number": 140,
      "text": "Appendix C – MIPS Instruction Set\nmulou  Rdest, Rsrc, Src\nUnsigned Multiply (with overflow)\nSets: $lo = Rsrc * Src (or imm)\nmult   Rsrc1, Rsrc2\nMultiply\nSets $hi:$lo = Rsrc / Src (or imm)\nmultu  Rsrc1, Rsrc2\nUnsigned Multiply\nSets $hi:$lo = Rsrc / Src (or imm)\nneg    Rdest, Rsrc\nNegate Value (with overflow)\nRdest = negative of integer in register \nRsrc\nrem    Rdest, Rsrc, Src\nRemainder after division\nRdest = remainder from Rsrc / Src (or \nimm)\nremu   Rdest, Rsrc, Src\nUnsigned Remainder\nRdest = remainder from Rsrc / Src (or \nimm)\nsub    Rdest, Rsrc, Src\nSubtract (with overflow)\nRdest = Rsrc – Src (or imm)\nsubu   Rdest, Rsrc, Src\nSubtract (without overflow)\nRdest = Rsrc – Src (or imm)\nPage 135",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.42 sec"
    },
    {
      "page_number": 141,
      "text": "Appendix C – MIPS Instruction Set\n 14.2 \nComparison Instructions\nBelow is a summary of the compare and set instructions.  Programmers generally use \nthe conditional branch and jump instructions as detailed in the next section.\nseq   Rdest, Rsrc1, Src2\nSet Equal\n- Sets register Rdest to 1 if register Rsrc1 \nequals Src2 and to 0 otherwise\nsge   Rdest, Rsrc1, Src2\nSet Greater Than Equal\n- Sets register Rdest to 1 if register Rsrc1 \nis greater than or equal Src2 and to 0 \notherwise\nsgeu  Rdest, Rsrc1, Src2\nSet Greater Than Equal, Unsigned\n- Sets register Rdest to 1 if register Rsrc1 \nis greater than or equal to Src2 and to 0 \notherwise\n \nsgt   Rdest, Rsrc1, Src2\nSet Greater Than\n- Sets register Rdest to 1 if register Rsrc1 \nis greater than Src2 and to 0 otherwise\nsgtu  Rdest, Rsrc1, Src2\nSet Greater Than, Unsigned\n- Sets register Rdest to 1 if register Rsrc1 \nis greater than Src2 and to 0 otherwise\nsle   Rdest, Rsrc1, Src2\nSet Less Than Equal\n- Sets register Rdest to 1 if register Rsrc1 \nis less than or equal to Src2 and to 0 \notherwise\nsleu  Rdest, Rsrc1, Src2\nSet Less Than Equal, Unsigned\n- Sets register Rdest to 1 if register Rsrc1 \nis less than or equal to Src2 and to 0 \notherwise\nPage 136",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 142,
      "text": "Appendix C – MIPS Instruction Set\nslt   Rdest, Rsrc1, Src2\nSet Less Than\n- Sets register Rdest to 1 if register Rsrc1 \nis less than to Src2 and to 0 otherwise\nslti   Rdest, Rsrc1, Imm\nSet Less Than, Immediate\n- Sets register Rdest to 1 if register Rsrc1 \nis less than or equal to Imm and to 0 \notherwise\nsltu   Rdest, Rsrc1, Src2\nSet Less Than, Unsigned\n- Sets register Rdest to 1 if register Rsrc1 \nis less than to Src2 and to 0 otherwise\nsltiu  Rdest, Rsrc1, Imm\nSet Less Than Unsigned, Immediate\n- Sets register Rdest to 1 if register Rsrc1 \nis less than Src2 (or Imm) and to 0 \notherwise\nsne    Rdest, Rsrc1, Src2\nSet Not Equal\n- Sets register Rdest to 1 if register Rsrc1 \nis not equal to Src2 and to 0 otherwise\n 14.3 \nBranch and Jump Instructions\nBelow are a summary of the basic conditional branch and jump instructions.\nb  label\nBranch instruction\n- Unconditionally branch to the instruction\nat the label\nbczt  label\nBranch Co-processor z True\n- Conditionally branch to the instruction at\nthe label if co-processor z's condition flag \nis true (false)\nPage 137",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 143,
      "text": "Appendix C – MIPS Instruction Set\nbczf  label\nBranch Co-processor z False\n- Conditionally branch to the instruction at\nthe label if co-processor z's condition flag \nis true (false)\n \nbeq   Rsrc1, Src2, label\nBranch on Equal\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nequals Src2\n \nbeqz  Rsrc, label\nBranch on Equal Zero\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc equals 0\n \nbge   Rsrc1, Src2, label\nBranch on Greater Than or Equal\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare greater than or equal to Src2\nbgeu  Rsrc1, Src2, label\nBranch on G Than or Equal, Unsigned\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare greater than or equal to Src2\nbgez  Rsrc, label\nBranch on Greater Than or Equal Zero\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are greater\nthan or equal to 0\n \nbgezal Rsrc, label\nBranch on Greater Than or Equal Zero \nand Link\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are greater\nthan or equal to 0.  Saves the address of \nthe next instruction in $ra\n \nPage 138",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 144,
      "text": "Appendix C – MIPS Instruction Set\nbgt    Rsrc1, Src2, label\nBranch on Greater Than\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nis greater than Src2\nbgtu    Rsrc1, Src2, label\nBranch on Greater Than, Unsigned\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare greater than Src2\n \nbgtz    Rsrc, label\nBranch on Greater Than Zero\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are greater\nthan 0\n \nble     Rsrc1, Src2, label\nBranch on Less Than or Equal\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare less than or equal to Src2\nbleu    Rsrc1, Src2, label\nBranch on Less Than or Equal, Unsigned\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare less than or equal to Src2\n \nblez    Rsrc, label\nBranch on Less Than or Equal Zero\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are less \nthan or equal to 0\n \nblezal  Rsrc, label\nBranch on Less Than Equal or Zero And \nLink\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are greater\nor equal to 0 or less than 0, respectively. \nSaves the address of the next instruction \nin register $ra\nPage 139",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 145,
      "text": "Appendix C – MIPS Instruction Set\nbltzal  Rsrc, label\nBranch on Less Than And Link\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are less \nthan 0 or less than 0, respectively.  Save \nthe address of the next instruction in \nregister $ra\n \nblt     Rsrc1, Src2, label\nBranch on Less Than\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare less than Src2\nbltu    Rsrc1, Src2, label\nBranch on Less Than, Unsigned\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare less than Src2\n \nbltz    Rsrc, label\nBranch on Less Than Zero\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are less \nthan 0\n \nbne     Rsrc1, Src2, label\nBranch on Not Equal\n- Conditionally branch to the instruction at\nthe label if the contents of register Rsrc1 \nare not equal to Src2\nbnez    Rsrc, label\nBranch on Not Equal Zero\n- Conditionally branch to the instruction at\nthe label if the contents of Rsrc are not \nequal to 0\n \nj       label\nJump\n- Unconditionally jump to the instruction \nat the label\nPage 140",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 146,
      "text": "Appendix C – MIPS Instruction Set\njal     label\nJump and Link\n- Unconditionally jump to the instruction \nat the label or whose address is in register \nRsrc.  Saves the address of the next \ninstruction in register $ra\njalr    Rsrc\nJump and Link Register\n- Unconditionally jump to the instruction \nat the label or whose address is in register \nRsrc.  Saves the address of the next \ninstruction in register $ra\njr      Rsrc\nJump Register\n- Unconditionally jump to the instruction \nwhose address is in register Rsrc\n 14.4 \nLoad Instructions\nBelow are a summary of the basic load instructions.\nla    Rdest, address\nLoad Address\n- Load computed address, not the contents\nof the location, into register Rdest\n \nlb    Rdest, address\nLoad Byte\n- Load the byte at address into register \nRdest. The byte is sign-extended by the \nlb, but not the lbu, instruction\nlbu   Rdest, address\nLoad Unsigned Byte\n- Load the byte at address into register \nRdest. The byte is sign-extended by the \nlb, but not the lbu, instruction\nld    Rdest, address\nLoad Double-Word\n- Load the 64-bit quantity at address into \nregisters Rdest and Rdest + 1\nPage 141",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 147,
      "text": "Appendix C – MIPS Instruction Set\nlh    Rdest, address\nLoad Halfword\n- Load the 16-bit quantity (halfword) at \naddress into register Rdest. The halfword \nis sign-extended\nlhu   Rdest, address\nLoad Unsigned Halfword\n- Load the 16-bit quantity (halfword) at \naddress into register Rdest. The halfword \nis not sign-extended\nlw    Rdest, address\nLoad Word\n- Load the 32-bit quantity (word) at \naddress into register Rdest\nlwcz  Rdest, address\nLoad Word Co-processor z\n- Load the word at address into register \nRdest of co-processor z (0-3)\nlwl   Rdest, address\nLoad Word Left\n- Load the left bytes from the word at the \npossibly-unaligned address into register \nRdest\nlwr   Rdest, address\nLoad Word Right\n- Load the right bytes from the word at the\npossibly-unaligned address into register \nRdest\nulh   Rdest, address\nUnaligned Load Halfword\n- Load the 16-bit quantity (halfword) at \nthe possibly-unaligned address into \nregister Rdest.  The halfword is sign-\nextended.\nPage 142",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 148,
      "text": "Appendix C – MIPS Instruction Set\nulhu  Rdest, address\nUnaligned Load Halfword Unsigned\n- Load the 16-bit quantity (halfword) at \nthe possibly-unaligned address into \nregister Rdest.  The halfword is not sign-\nextended\nulw   Rdest, address\nUnaligned Load Word\n- Load the 32-bit quantity (word) at the \npossibly-unaligned address into register \nRdest\nli    Rdest, imm\nLoad Immediate\n- Move the immediate imm into register \nRdest\nlui   Rdest, imm\nLoad Upper Immediate\n- Load the lower halfword of the \nimmediate imm into the upper halfword of\nregister Rdest. The lower bits of the \nregister is set to 0\n 14.5 \nLogical Instructions\nBelow are a summary of the basic logical instructions.\nand    Rdest, Rsrc1, Src2\nAND\nandi   Rdest, Rsrc1, Imm\nAND Immediate\n- Put the logical AND of the integers from\nregister Rsrc1 and Src2 (or Imm) into \nregister Rdest\nnor    Rdest, Rsrc1, Src2\nNOR\n- Put the logical NOR of the integers from\nregister Rsrc1 and Src2 into register Rdest\nPage 143",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 149,
      "text": "Appendix C – MIPS Instruction Set\nnot   Rdest, Rsrc\nNOT\n- Put the bitwise logical negation of the \ninteger from register Rsrc into register \nRdest\n \nor    Rdest, Rsrc1, Src2\nOR\n- Put the logical OR of the integers from \nregister Rsrc1 and Src2 into register Rdest\nori   Rdest, Rsrc1, Imm\nOR Immediate\n- Put the logical OR of the integers from \nregister Rsrc1 and Imm into register Rdest\nrol   Rdest, Rsrc1, Src2\nRotate Left\n- Rotate the contents of register Rsrc1 left \nby the distance indicated by Src2 and put \nthe result in register Rdest\nror   Rdest, Rsrc1, Src2\nRotate Right\n- Rotate the contents of register Rsrc1 left \n(right) by the distance indicated by Src2 \nand put the result in register Rdest\nsll   Rdest, Rsrc1, Src2\nShift Left Logical\n- Shift the contents of register Rsrc1 left \nby the distance indicated by Src2 and put \nthe result in register Rdest\nsra   Rdest, Rsrc1, Src2\nShift Right Arithmetic\n- Shift the contents of register Rsrc1 right \nby the distance indicated by Src2 and put \nthe result in register Rdest\nsrl   Rdest, Rsrc1, Src2\nShift Right Logical\n- Shift the contents of register Rsrc1 right \nby the distance indicated by Src2 and put \nthe result in register Rdest\nPage 144",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 150,
      "text": "Appendix C – MIPS Instruction Set\nxor   Rdest, Rsrc1, Src2\nXOR\n- Put the logical XOR of the integers from\nregister Rsrc1 and Src2 into register Rdest\nxori  Rdest, Rsrc1, Imm\nXOR Immediate\n- Put the logical XOR of the integers from\nregister Rsrc1 and Imm into register Rdest\n 14.6 \nStore Instructions\nBelow are a summary of the basic store instructions.\nsb   Rsrc, address\nStore Byte\n- Store the low byte from register Rsrc at \naddress\nsd   Rsrc, address\nStore Double-Word\n- Store the 64-bit quantity in registers Rsrc\nand Rsrc + 1 at address\nsh    Rsrc, address\nStore Halfword\n- Store the low halfword from register \nRsrc at address\nsw    Rsrc, address\nStore Word\n- Store the word from register Rsrc at \naddress\nswcz  Rsrc, address\nStore Word Co-processor z\n- Store the word from register Rsrc of co-\nprocessor z at address\nswl   Rsrc, address\nStore Word Left\n- Store the left bytes from register Rsrc at \nthe possibly-unaligned address\nPage 145",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 151,
      "text": "Appendix C – MIPS Instruction Set\nswr   Rsrc, address\nStore Word Right\n- Store the right bytes from register Rsrc \nat the possibly-unaligned address\nush   Rsrc, address\nUnaligned Store Halfword\n- Store the low halfword from register \nRsrc at the possibly-unaligned address\nusw   Rsrc, address\nUnaligned Store Word\n- Store the word from register Rsrc at the \npossibly-unaligned address\n 14.7 \nData Movement Instructions\nBelow are a summary of the basic data movement instructions.  The data movement \nimplies data movement between registers.\nmove   Rdest, Rsrc \nMove the contents of Rsrc to Rdest. \n- The multiply and divide unit produces its\nresult in two additional registers, $hi and \n$lo. These instructions move values to and\nfrom these registers.  The multiply, divide,\nand remainder instructions described \nabove are pseudo-instructions that make it \nappear as if this unit operates on the \ngeneral registers and detect error \nconditions such as divide by zero or \noverflow. \nmfhi  Rdest \nMove from $hi\n- Move the contents of the hi register to \nregister Rdest\nmflo  Rdest \nMove from $lo\n- Move the contents of the lo register to \nregister Rdest\nPage 146",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 152,
      "text": "Appendix C – MIPS Instruction Set\nmthi  Rdest \nMove to $hi\n- Move the contents register Rdest to the \nhi register. \n- Note, Co-processors have their own \nregister sets. This instruction move values \nbetween these registers and the CPU's \nregisters.\nmtlo  Rdest \nMove to $lo\n- Move the contents register Rdest to the \nlo register. \n- Note, Co-processors have their own \nregister sets. This instruction move values \nbetween these registers and the CPU's \nregisters.\n \nmfc1  Rdest, FRsrc \nMove From Co-processor 1\n- Move the contents of co-processor 1 float\nregister FRsrc to CPU integer register \nRdest\nmfc1.d  Rdest, FRsrc1 \nMove Double From Co-processor 1\n- Move the contents of floating-point \nregisters FRsrc1 and FRsrc1+1 to CPU \ninteger registers Rdest and Rdest + 1\nmtc1    Rsrc, FRdest\nMove To Co-processor 1\n- Move the contents of CPU integer \nregister Rsrc to co-processor 1 float \nregister FRdest\nmtc1.d  Rsrc, FRdest\nMove To Co-processor 1\n- Move the contents of CPU integer \nregisters Rsrc and Rsrc+1 to co-processor \n1 float registers Frdest and FRdest+1.\nPage 147",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.43 sec"
    },
    {
      "page_number": 153,
      "text": "Appendix C – MIPS Instruction Set\n 14.8 \nFloating-Point Instructions\nThe MIPS has a floating-point co-processor (numbered 1) that operates on single \nprecision (32-bit) and double precision (64-bit) floating-point numbers.  This co-\nprocessor has its own registers, which are numbered $f0 - $f31.  Because these registers \nare only 32-bits wide, two of them are required to hold doubles. To simplify matters, \nfloating-point operations only use even-numbered registers - including instructions that \noperate on single floats.  Values are moved in or out of these registers a word (32-bits) \nat a time by lwc1, swc1, mtc1, and mfc1 instructions described above or by the l.s, l.d, \ns.s, and s.d pseudo-instructions described below.  The flag set by floating-point \ncomparison operations is read by the CPU with its bc1t and bc1f instructions.  In all \ninstructions below, FRdest, FRsrc1, FRsrc2, and FRsrc are floating-point registers.\nabs.d  FRdest, FRsrc\nFloating-point Absolute Value, Double\n- Compute the absolute value of the \nfloating-point double in register FRsrc and\nput it in register FRdest\nabs.s   FRdest, FRsrc\nFloating-point Absolute Value, Single\n- Compute the absolute value of the \nfloating-point single in register FRsrc and \nput it in register FRdest\nadd.d   FRdest, FRsrc1,\n   FRsrc2\nFloating-point Addition, Double\n- Compute the sum of the floating-point \ndoubles in registers FRsrc1 and FRsrc2 \nand put it in register FRdest\nadd.s   FRdest, FRsrc1,\n                   FRsrc2\nFloating-point Addition, Single\n- Compute the sum of the floating-point \nsingles in registers FRsrc1 and FRsrc2 and\nput it in register FRdest\nc.eq.d  FRsrc1, FRsrc2\nCompare Equal, Double\n- Compare the floating-point double in \nregister FRsrc1 against the one in FRsrc2 \nand set the floating-point condition flag \ntrue if they are equal\nPage 148",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 154,
      "text": "Appendix C – MIPS Instruction Set\nc.eq.s  FRsrc1, FRsrc2\nCompare Equal, Single\n- Compare the floating-point single in \nregister FRsrc1 against the one in FRsrc2 \nand set the floating-point condition flag \ntrue if they are equal\nc.le.d  FRsrc1, FRsrc2\nCompare Less Than or Equal, Double\n- Compare the floating-point double in \nregister FRsrc1 against the one in FRsrc2 \nand set the floating-point condition flag \ntrue if the first is less than or equal to the \nsecond\nc.le.s  FRsrc1, FRsrc2\nCompare Less Than or Equal, Single\n- Compare the floating-point single \nprecision in register FRsrc1 against the \none in FRsrc2 and set the floating-point \ncondition flag true if the first is less than \nor equal to the second\nc.lt.d  FRsrc1, FRsrc2\nCompare Less Than, Double\n- Compare the floating-point double in \nregister FRsrc1 against the one in FRsrc2 \nand set the condition flag true if the first is\nless than the second\nc.lt.s  FRsrc1, FRsrc2\nCompare Less Than, Single\n- Compare the floating-point single in \nregister FRsrc1 against the one in FRsrc2 \nand set the condition flag true if the first is\nless than the second\ncvt.d.s  FRdest, FRsrc\nConvert Single to Double\n- Convert the single precision floating-\npoint number in register FRsrc to a double\nprecision number and put it in register \nFRdest\nPage 149",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 155,
      "text": "Appendix C – MIPS Instruction Set\ncvt.d.w  FRdest, FRsrc\nConvert Integer to Double\n- Convert the integer in register FRsrc to a \ndouble precision number and put it in \nregister FRdest\ncvt.s.d  FRdest, FRsrc\nConvert Double to Single\n- Convert the double precision floating-\npoint number in register FRsrc to a single \nprecision number and put it in register \nFRdest\ncvt.s.w  FRdest, FRsrc\nConvert Integer to Single\n- Convert the integer in register FRsrc to a \nsingle precision number and put it in \nregister FRdest\ncvt.w.d  FRdest, FRsrc\nConvert Double to Integer\n- Convert the double precision floating-\npoint number in register FRsrc to an \ninteger and put it in register FRdest\ncvt.w.s  FRdest, FRsrc\nConvert Single to Integer\n- Convert the single precision floating-\npoint number in register FRsrc to an \ninteger and put it in register FRdest\ndiv.d    FRdest, FRsrc1,\n   FRsrc2\nFloating-point Divide, Double\n- Compute the quotient of the floating-\npoint doubles in registers FRsrc1 and \nFRsrc2 and put it in register FRdest.\ndiv.s    FRdest, FRsrc1,\n   FRsrc2\nFloating-point Divide, Single\n- Compute the quotient of the floating-\npoint singles in registers FRsrc1 and \nFRsrc2 and put it in register FRdest.\nPage 150",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 156,
      "text": "Appendix C – MIPS Instruction Set\nl.d      FRdest, address\nLoad Floating-point, Double\n- Load the floating-point double at address\ninto register FRdest\nl.s     FRdest, address\nLoad Floating-point, Single\n- Load the floating-point single at address \ninto register FRdest\nmov.d   FRdest, FRsrc\nMove Floating-point, Double\n- Move the floating-point double from \nregister FRsrc to register FRdest\nmov.s  FRdest, FRsrc\nMove Floating-point, Single\n- Move the floating-point single from \nregister FRsrc to register FRdest\nmul.d  FRdest, FRsrc1,\n   FRsrc2\nFloating-point Multiply, Double\n- Compute the product of the floating-\npoint doubles in registers FRsrc1 and \nFRsrc2 and put it in register FRdest\nmul.s  FRdest, FRsrc1,\n   FRsrc2\nFloating-point Multiply, Single\n- Compute the product of the floating-\npoint singles in registers FRsrc1 and \nFRsrc2 and put it in register FRdest\nneg.d  FRdest, FRsrc\nNegate, Double\n- Store the floating-point double in register\nFRdest at address\nneg.s  FRdest, FRsrc\nNegate, Single\nStore the floating-point single in register \nFRdest at address\ns.d    FRdest, address\nStore Floating-point Double\n- Store the floating-point double in register\nFRdest at address\nPage 151",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 157,
      "text": "Appendix C – MIPS Instruction Set\ns.s    FRdest, address\nStore Floating-point, Single\n- Store the floating-point single in register \nFRdest at address\nsub.d  FRdest, FRsrc1,\n   FRsrc2\nFloating-point Subtract, Double\n- Compute the difference of the floating-\npoint doubles in registers FRsrc1 and \nFRsrc2 and put it in register FRdest\nsub.s   FRdest, FRsrc1,\n   FRsrc2\nFloating-point Subtract, Single\n- Compute the difference of the floating-\npoint singles in registers FRsrc1 and \nFRsrc2 and put it in register FRdest\n 14.9 \nException and Trap Handling Instructions\nBelow are a summary of the exception and trap instructions.\nrfe \nReturn From Exception\n- Restore the Status register\nsyscall \nSystem Call\n- Transfer control to system routine.  \nRegister $v0 contains the number of the \nsystem call\nbreak  n\nBreak\n- Cause exception n.\n- Note, Exception 1 is reserved for the \ndebugger\nnop \nNo operation\n- Do nothing\nPage 152",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 158,
      "text": "15.0\nAppendix D – ASCII Table\nThis appendix provides a copy of the ASCII Table for reference.\nChar\nDec\nHex\nChar\nDec\nHex\nChar\nDec\nHex\nChar\nDec\nHex\nNUL\n0\n0x00\n spc \n32\n0x20\n@ \n64\n0x40\n` \n96\n0x60\nSOH\n1\n0x01\n! \n33\n0x21\nA \n65\n0x41\na \n97\n0x61\nSTX\n2\n0x02\n\" \n34\n0x22\nB \n66\n0x42\nb \n98\n0x62\nETX\n3\n0x03\n# \n35\n0x23\nC \n67\n0x43\nc \n99\n0x63\nEOT\n4\n0x04\n$ \n36\n0x24\nD \n68\n0x44\nd \n100\n0x64\nENQ\n5\n0x05\n% \n37\n0x25\nE \n69\n0x45\ne \n101\n0x65\nACK\n6\n0x06\n& \n38\n0x26\nF \n70\n0x46\nf \n102\n0x66\nBEL\n7\n0x07\n' \n39\n0x27\nG \n71\n0x47\ng \n103\n0x67\nBS\n8\n0x08\n( \n40\n0x28\nH \n72\n0x48\nh \n104\n0x68\nTAB\n9\n0x09\n) \n41\n0x29\nI \n73\n0x49\ni \n105\n0x69\nLF\n10\n0x0A\n* \n42\n0x2A\nJ \n74\n0x4A\nj \n106\n0x6A\nVT\n11\n0x0B\n+ \n43\n0x2B\nK \n75\n0x4B\nk \n107\n0x6B\nFF\n12\n0x0C\n, \n44\n0x2C\nL \n76\n0x4C\nl \n108\n0x6C\nCR\n13\n0x0D\n- \n45\n0x2D\nM \n77\n0x4D\nm \n109\n0x6D\nSO\n14\n0x0E\n. \n46\n0x2E\nN \n78\n0x4E\nn \n110\n0x6E\nSI\n15\n0x0F\n/ \n47\n0x2F\nO \n79\n0x4F\no \n111\n0x6F\nDLE\n16\n0x10\n0\n48\n0x30\nP \n80\n0x50\np \n112\n0x70\nDC1\n17\n0x11\n1\n49\n0x31\nQ \n81\n0x51\nq \n113\n0x71\nDC2\n18\n0x12\n2\n50\n0x32\nR \n82\n0x52\nr \n114\n0x72\nDC3\n19\n0x13\n3\n51\n0x33\nS \n83\n0x53\ns \n115\n0x73\nDC4\n20\n0x14\n4\n52\n0x34\nT \n84\n0x54\nt \n116\n0x74\nNAK\n21\n0x15\n5\n53\n0x35\nU \n85\n0x55\nu \n117\n0x75\nSYN\n22\n0x16\n6\n54\n0x36\nV \n86\n0x56\nv \n118\n0x76\nETB\n23\n0x17\n7\n55\n0x37\nW \n87\n0x57\nw \n119\n0x77\nCAN\n24\n0x18\n8\n56\n0x38\nX \n88\n0x58\nx \n120\n0x78\nPage 153",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 159,
      "text": "Appendix D – ASCII Table\nEM\n25\n0x19\n9\n57\n0x39\nY \n89\n0x59\ny \n121\n0x79\nSUB\n26\n0x1A\n: \n58\n0x3A\nZ \n90\n0x5A\nz \n122\n0x7A\nESC\n27\n0x1B\n; \n59\n0x3B\n[ \n91\n0x5B\n{ \n123\n0x7B\nFS\n28\n0x1C\n< \n60\n0x3C\n\\ \n92\n0x5C\n| \n124\n0x7C\nGS\n29\n0x1D\n= \n61\n0x3D\n] \n93\n0x5D\n} \n125\n0x7D\nRS\n30\n0x1E\n> \n62\n0x3E\n^ \n94\n0x5E\n~ \n126\n0x7E\nUS\n31\n0x1F\n? \n63\n0x3F\n_ \n95\n0x5F\n DEL\n127\n0x7F\nFor additional information and a more complete listing of the ASCII codes (including \nthe extended ASCII characters), refer to http://www.asciitable.com/\nPage 154",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 160,
      "text": "16.0\nAlphabetical Index\n0x............................................................26\nabs...........................................................30\nactivation record.....................................71\nadd..........................................................29\nAddressing Modes..................................53\naddu........................................................29\nAllocate Memory....................................84\nand..........................................................33\nArchitecture Overview.............................3\nArgument Transmission.........................68\nArgument Transmission Conventions....68\nAssembler Directives..............................19\nAssembly Process...................................19\nassembly source file...............................19\nBare-Instructions....................................25\nbeq..........................................................40\nbge..........................................................40\nbgeu........................................................40\nbgt...........................................................40\nbgtu.........................................................40\nbiased exponent......................................15\nble...........................................................40\nbleu.........................................................40\nblt............................................................40\nbltu..........................................................40\nbne..........................................................40\nbyte...........................................................4\nbyte addressable........................................4\nCall Frame..............................................71\nCall-by-Reference...................................68\nCall-by-Value.........................................68\nCaller Conventions.................................66\nColumn-Major........................................95\nComments...............................................19\nConditional Control Instructions............39\nConstants................................................22\nControl Instructions................................39\nCPU register.............................................6\nData Declarations...................................20\nData Movement......................................26\nData representation.................................11\ndata types..................................................4\nDestination operand................................25\nDirect addressing mode..........................53\ndisplacement addressing.........................54\ndiv........................................................29p.\ndivu.........................................................30\ndouble.......................................................4\ndouble-precision.....................................43\nend directive...........................................66\nentry point directive................................66\nexception cause register............................8\nFile Close................................................84\nFile Open................................................84\nfile open access flags..............................84\nFile Read.................................................84\nFile Write................................................84\nfloat...........................................................4\nFloating-Point Arithmetic Operations....47\nFloating-Point Data Declarations...........22\nFloating-Point Data Movement..............43\nFloating-Point Instructions.....................42\nFloating-Point Register Usage................42\nfloating-point registers..............................6\nPage 155",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 161,
      "text": "Alphabetical Index\nFloating-point Representation................14\nFPU co-processor.....................................9\nFRdest.....................................................26\nFRsrc.......................................................26\nFunction Results.....................................69\nglobal declaration directive....................66\nhalfword....................................................4\nheap...........................................................6\nIEEE 32-bit Representation....................14\nIEEE 64-bit Representation....................17\nIEEE 754 32-bit floating-point standard 14\nIF statement............................................39\nImmediate addressing mode...................53\nImmediate value.....................................26\nindirect memory access..........................54\nIndirection...............................................54\nInteger / Floating-Point Conversion \nInstructions.............................................45\nInteger / Floating-Point Register Data \nMovement...............................................44\nInteger Data Declarations.......................20\ninteger numbers......................................11\ninteger registers........................................6\nj <label>..................................................39\njal <procName>......................................67\njr $ra........................................................67\nl<type>....................................................27\nla.............................................................27\nLabels.....................................................23\nlb.............................................................27\nLeaf procedures......................................65\nLeast Significant Byte..............................4\nlh.............................................................27\nli..............................................................27\nLinkage...................................................67\nlittle-endian............................................4p.\nLoad and Store........................................26\nlogical AND operation...........................34\nlogical NOR operation............................34\nlogical NOT operation............................34\nlogical OR operation...............................34\nlogical XOR operation............................34\nlw............................................................27\nmain function/procedure.........................23\nMemory....................................................4\nmemory layout..........................................6\nmfc1........................................................44\nmfc1.d.....................................................44\nmfhi.........................................................28\nmflo.........................................................28\nMIPS Calling Conventions.....................65\nmiscellaneous registers.............................8\nMost Significant Byte...............................4\nmove.......................................................28\nMove.......................................................28\nmtc1........................................................44\nmtc1.d.....................................................45\nmthi.........................................................28\nmtlo.........................................................28\nmul..........................................................29\nmulo........................................................29\nmulou......................................................29\nmult.........................................................29\nMulti-dimension Array Implementation.93\nMultiple push's/pop's..............................61\nmultu.......................................................29\nneg..........................................................30\nNon-leaf procedures...............................65\nnor...........................................................33\nnormalized scientific notation................15\nnot...........................................................34\nNotational Conventions..........................25\nOperand Notation...................................25\noperands..................................................25\noperation.................................................25\nor.............................................................34\nPage 156",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.44 sec"
    },
    {
      "page_number": 162,
      "text": "Alphabetical Index\nPop..........................................................61\npop operation..........................................59\nPrimary Storage........................................3\nPrint Character........................................84\nPrint Double............................................82\nPrint Float...............................................82\nPrint Integer............................................82\nPrint String..............................................82\nProcedure/Function Format....................66\nProcedures/Functions.............................65\nProgram Code.........................................23\nprogram counter........................................8\nProgram Template..................................24\nPseudo-Instructions................................25\nPush........................................................60\npush operation........................................59\nQtSpim Program Formats.......................19\nQtSpim System Services........................82\nRAM.........................................................3\nRandom Access Memory.........................3\nRead Character.......................................84\nRead Double...........................................84\nRead Float...............................................82\nRead Integer............................................82\nRead String.............................................84\nRecursion................................................99\nrecursive relation....................................99\nregister......................................................6\nregister names...........................................7\nregister usage............................................7\nRegisters Preservation Conventions.......69\nrem..........................................................30\nremu........................................................30\nreserved registers......................................7\nrol............................................................34\nror...........................................................34\nRow-Major.............................................94\ns<type>...................................................27\nsb.............................................................27\nSecondary Storage....................................3\nsh.............................................................27\nsigned......................................................11\nsingle-precision.......................................43\nsll............................................................34\nSource operand.......................................25\nsra...........................................................34\nsrl............................................................34\nStack.......................................................59\nStack Dynamic Local Variables.............71\nStack Implementation.............................60\nstack pointer register.................................6\nstatus register............................................8\nString Data Declarations.........................21\nsub...........................................................29\nsubu.........................................................29\nsw............................................................27\nTerminate................................................84\ntwo's complement................................12p.\nUnconditional Control Instructions........39\nuninitialized data......................................6\nunsigned..................................................11\nvoid function...........................................65\nword..........................................................4\nxor...........................................................34\n.ascii........................................................20\n.asciiz......................................................20\n.byte........................................................20\n.d.............................................................43\n.data........................................................20\n.double....................................................20\n.end <functionName>.............................66\n.ent..........................................................23\n.float........................................................20\n.globl.......................................................23\n.half.........................................................20\n.s..............................................................43\nPage 157",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.45 sec"
    },
    {
      "page_number": 163,
      "text": "Alphabetical Index\n.space <n>...............................................20\n.text.........................................................23\n.word.......................................................20\n$cause.......................................................8\n$hi.............................................................8\n$lo.............................................................8\n$pc............................................................8\n$psw..........................................................8\n$status.......................................................8\nPage 158",
      "tables": "No table support in fitz.",
      "images": [],
      "img_summary_files": [],
      "img_vision_files": [],
      "time_taken": "44.45 sec"
    }
  ],
  "overall_summary": "PDF extraction complete.",
  "total_time_taken": "44.45 sec"
}